<!DOCTYPE html>
<html class="no-js" lang="zh">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width,initial-scale=1" name="viewport"/>
<meta content="shad0wash 的笔记本" name="description"/>
<link href="https://note.shad0wash.cc/papers/RandomOracles/" rel="canonical"/>
<link href="../" rel="prev"/>
<link href="../../assets/images/favicon.png" rel="icon"/>
<meta content="mkdocs-1.4.2, mkdocs-material-9.0.4" name="generator"/>
<title>Random Oracles in a Quantum World - shad0wash's notebook</title>
<link href="../../assets/stylesheets/main.9c788c91.min.css" rel="stylesheet"/>
<link href="../../assets/stylesheets/palette.2505c338.min.css" rel="stylesheet"/>
<link href="../../css/svg.css" rel="stylesheet"/>
<link href="../../css/heti.css" rel="stylesheet"/>
<link href="../../css/svg_extra.css" rel="stylesheet"/>
<link href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css" rel="stylesheet"/>
<link href="https://gcore.jsdelivr.net/npm/lxgw-wenkai-screen-webfont@1.1.0/style.css" rel="stylesheet"/>
<link href="https://gcore.jsdelivr.net/npm/lxgw-wenkai-webfont@1.1.0/style.css" rel="stylesheet"/>
<link href="../../css/stylesheet.css" rel="stylesheet"/>
<link href="../../css/flink.css" rel="stylesheet"/>
<script>__md_scope=new URL("../..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
</head>
<body data-md-color-accent="" data-md-color-primary="" data-md-color-scheme="default" dir="ltr">
<script>var palette=__md_get("__palette");if(palette&&"object"==typeof palette.color)for(var key of Object.keys(palette.color))document.body.setAttribute("data-md-color-"+key,palette.color[key])</script>
<input autocomplete="off" class="md-toggle" data-md-toggle="drawer" id="__drawer" type="checkbox"/>
<input autocomplete="off" class="md-toggle" data-md-toggle="search" id="__search" type="checkbox"/>
<label class="md-overlay" for="__drawer"></label>
<div data-md-component="skip">
<a class="md-skip" href="#random-oracles-in-a-quantum-world">
          跳转至
        </a>
</div>
<div data-md-component="announce">
</div>
<header class="md-header" data-md-component="header">
<nav aria-label="页眉" class="md-header__inner md-grid">
<a aria-label="shad0wash's notebook" class="md-header__button md-logo" data-md-component="logo" href="../.." title="shad0wash's notebook">
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"></path></svg>
</a>
<label class="md-header__button md-icon" for="__drawer">
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"></path></svg>
</label>
<div class="md-header__title" data-md-component="header-title">
<div class="md-header__ellipsis">
<div class="md-header__topic">
<span class="md-ellipsis">
            shad0wash's notebook
          </span>
</div>
<div class="md-header__topic" data-md-component="header-topic">
<span class="md-ellipsis">
            
              Random Oracles in a Quantum World
            
          </span>
</div>
</div>
</div>
<form class="md-header__option" data-md-component="palette">
<input aria-label="Switch to dark mode" class="md-option" data-md-color-accent="" data-md-color-media="(prefers-color-scheme: light)" data-md-color-primary="" data-md-color-scheme="default" id="__palette_1" name="__palette" type="radio"/>
<label class="md-header__button md-icon" for="__palette_2" hidden="" title="Switch to dark mode">
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M12 8a4 4 0 0 0-4 4 4 4 0 0 0 4 4 4 4 0 0 0 4-4 4 4 0 0 0-4-4m0 10a6 6 0 0 1-6-6 6 6 0 0 1 6-6 6 6 0 0 1 6 6 6 6 0 0 1-6 6m8-9.31V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12 20 8.69Z"></path></svg>
</label>
<input aria-label="Switch to light mode" class="md-option" data-md-color-accent="" data-md-color-media="(prefers-color-scheme: dark)" data-md-color-primary="" data-md-color-scheme="slate" id="__palette_2" name="__palette" type="radio"/>
<label class="md-header__button md-icon" for="__palette_1" hidden="" title="Switch to light mode">
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M12 18c-.89 0-1.74-.2-2.5-.55C11.56 16.5 13 14.42 13 12c0-2.42-1.44-4.5-3.5-5.45C10.26 6.2 11.11 6 12 6a6 6 0 0 1 6 6 6 6 0 0 1-6 6m8-9.31V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12 20 8.69Z"></path></svg>
</label>
</form>
<label class="md-header__button md-icon" for="__search">
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"></path></svg>
</label>
<div class="md-search" data-md-component="search" role="dialog">
<label class="md-search__overlay" for="__search"></label>
<div class="md-search__inner" role="search">
<form class="md-search__form" name="search">
<input aria-label="搜索" autocapitalize="off" autocomplete="off" autocorrect="off" class="md-search__input" data-md-component="search-query" name="query" placeholder="搜索" required="" spellcheck="false" type="text"/>
<label class="md-search__icon md-icon" for="__search">
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"></path></svg>
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"></path></svg>
</label>
<nav aria-label="查找" class="md-search__options">
<button aria-label="清空当前内容" class="md-search__icon md-icon" tabindex="-1" title="清空当前内容" type="reset">
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"></path></svg>
</button>
</nav>
</form>
<div class="md-search__output">
<div class="md-search__scrollwrap" data-md-scrollfix="">
<div class="md-search-result" data-md-component="search-result">
<div class="md-search-result__meta">
            正在初始化搜索引擎
          </div>
<ol class="md-search-result__list"></ol>
</div>
</div>
</div>
</div>
</div>
<div class="md-header__source">
<a class="md-source" data-md-component="source" href="https://github.com/shadowash0215/notebook" title="前往仓库">
<div class="md-source__icon md-icon">
<svg viewbox="0 0 448 512" xmlns="http://www.w3.org/2000/svg"><!--! Font Awesome Free 6.2.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"></path></svg>
</div>
<div class="md-source__repository">
    shadowash/notebook
  </div>
</a>
</div>
</nav>
</header>
<div class="md-container" data-md-component="container">
<nav aria-label="标签" class="md-tabs" data-md-component="tabs">
<div class="md-tabs__inner md-grid">
<ul class="md-tabs__list">
<li class="md-tabs__item">
<a class="md-tabs__link" href="../..">
        Home
      </a>
</li>
<li class="md-tabs__item">
<a class="md-tabs__link" href="../../cs/">
        Computer Science
      </a>
</li>
<li class="md-tabs__item">
<a class="md-tabs__link" href="../../math/">
        Math
      </a>
</li>
<li class="md-tabs__item">
<a class="md-tabs__link" href="../../crypto/">
        Crypto
      </a>
</li>
<li class="md-tabs__item">
<a class="md-tabs__link md-tabs__link--active" href="../">
        Papers
      </a>
</li>
</ul>
</div>
</nav>
<main class="md-main" data-md-component="main">
<div class="md-main__inner md-grid">
<div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation">
<div class="md-sidebar__scrollwrap">
<div class="md-sidebar__inner">
<nav aria-label="导航栏" class="md-nav md-nav--primary md-nav--lifted" data-md-level="0">
<label class="md-nav__title" for="__drawer">
<a aria-label="shad0wash's notebook" class="md-nav__button md-logo" data-md-component="logo" href="../.." title="shad0wash's notebook">
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"></path></svg>
</a>
    shad0wash's notebook
  </label>
<div class="md-nav__source">
<a class="md-source" data-md-component="source" href="https://github.com/shadowash0215/notebook" title="前往仓库">
<div class="md-source__icon md-icon">
<svg viewbox="0 0 448 512" xmlns="http://www.w3.org/2000/svg"><!--! Font Awesome Free 6.2.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"></path></svg>
</div>
<div class="md-source__repository">
    shadowash/notebook
  </div>
</a>
</div>
<ul class="md-nav__list" data-md-scrollfix="">
<li class="md-nav__item md-nav__item--nested">
<input class="md-nav__toggle md-toggle" data-md-toggle="__nav_1" id="__nav_1" type="checkbox"/>
<div class="md-nav__link md-nav__link--index">
<a href="../..">Home</a>
<label for="__nav_1">
<span class="md-nav__icon md-icon"></span>
</label>
</div>
<nav aria-label="Home" class="md-nav" data-md-level="1">
<label class="md-nav__title" for="__nav_1">
<span class="md-nav__icon md-icon"></span>
          Home
        </label>
<ul class="md-nav__list" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link" href="../../links/">
        友链喵
      </a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item md-nav__item--nested">
<input class="md-nav__toggle md-toggle" data-md-toggle="__nav_2" id="__nav_2" type="checkbox"/>
<div class="md-nav__link md-nav__link--index">
<a href="../../cs/">Computer Science</a>
<label for="__nav_2">
<span class="md-nav__icon md-icon"></span>
</label>
</div>
<nav aria-label="Computer Science" class="md-nav" data-md-level="1">
<label class="md-nav__title" for="__nav_2">
<span class="md-nav__icon md-icon"></span>
          Computer Science
        </label>
<ul class="md-nav__list" data-md-scrollfix="">
<li class="md-nav__item md-nav__item--nested">
<input class="md-nav__toggle md-toggle" data-md-toggle="__nav_2_2" id="__nav_2_2" type="checkbox"/>
<div class="md-nav__link md-nav__link--index">
<a href="../../cs/fds/">fds</a>
<label for="__nav_2_2">
<span class="md-nav__icon md-icon"></span>
</label>
</div>
<nav aria-label="fds" class="md-nav" data-md-level="2">
<label class="md-nav__title" for="__nav_2_2">
<span class="md-nav__icon md-icon"></span>
          fds
        </label>
<ul class="md-nav__list" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link" href="../../cs/fds/mistakes/">
        Mistakes Collection
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../cs/fds/linkedlist/">
        链表
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../cs/fds/stack_queue/">
        栈和队列
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../cs/fds/tree/">
        树
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../cs/fds/heap/">
        堆
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../cs/fds/union_find/">
        并查集
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../cs/fds/graph/">
        图
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../cs/fds/sort/">
        排序
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../cs/fds/hash/">
        哈希
      </a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item md-nav__item--nested">
<input class="md-nav__toggle md-toggle" data-md-toggle="__nav_2_3" id="__nav_2_3" type="checkbox"/>
<div class="md-nav__link md-nav__link--index">
<a href="../../cs/ads/">ads</a>
<label for="__nav_2_3">
<span class="md-nav__icon md-icon"></span>
</label>
</div>
<nav aria-label="ads" class="md-nav" data-md-level="2">
<label class="md-nav__title" for="__nav_2_3">
<span class="md-nav__icon md-icon"></span>
          ads
        </label>
<ul class="md-nav__list" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link" href="../../cs/ads/Lec1/">
        AVL 树, Splay 树, 摊还分析
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../cs/ads/Lec2/">
        红黑树, b+ 树
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../cs/ads/Lec3/">
        倒排索引
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../cs/ads/Lec4/">
        左式堆, 斜堆
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../cs/ads/Lec5/">
        二项堆
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../cs/ads/Lec6/">
        回溯
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../cs/ads/Lec7/">
        分治
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../cs/ads/Lec8/">
        动态规划
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../cs/ads/Lec9/">
        贪心算法
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../cs/ads/Lec10/">
        $\mathsf{NP}$ 完全性
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../cs/ads/Lec11/">
        近似算法
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../cs/ads/Lec12/">
        局部搜索
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../cs/ads/Lec13/">
        随机算法
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../cs/ads/Lec14/">
        并行算法
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../cs/ads/HW_archive/">
        Homework archive
      </a>
</li>
</ul>
</nav>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item md-nav__item--nested">
<input class="md-nav__toggle md-toggle" data-md-toggle="__nav_3" id="__nav_3" type="checkbox"/>
<div class="md-nav__link md-nav__link--index">
<a href="../../math/">Math</a>
<label for="__nav_3">
<span class="md-nav__icon md-icon"></span>
</label>
</div>
<nav aria-label="Math" class="md-nav" data-md-level="1">
<label class="md-nav__title" for="__nav_3">
<span class="md-nav__icon md-icon"></span>
          Math
        </label>
<ul class="md-nav__list" data-md-scrollfix="">
<li class="md-nav__item md-nav__item--nested">
<input class="md-nav__toggle md-toggle" data-md-toggle="__nav_3_2" id="__nav_3_2" type="checkbox"/>
<div class="md-nav__link md-nav__link--index">
<a href="../../math/AbstractAlgebra/">AbstractAlgebra</a>
<label for="__nav_3_2">
<span class="md-nav__icon md-icon"></span>
</label>
</div>
<nav aria-label="AbstractAlgebra" class="md-nav" data-md-level="2">
<label class="md-nav__title" for="__nav_3_2">
<span class="md-nav__icon md-icon"></span>
          AbstractAlgebra
        </label>
<ul class="md-nav__list" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link" href="../../math/AbstractAlgebra/introduction/">
        Introduction
      </a>
</li>
<li class="md-nav__item md-nav__item--nested">
<input class="md-nav__toggle md-toggle" data-md-toggle="__nav_3_2_3" id="__nav_3_2_3" type="checkbox"/>
<div class="md-nav__link md-nav__link--index">
<a href="../../math/AbstractAlgebra/ChapterI/">ChapterI</a>
<label for="__nav_3_2_3">
<span class="md-nav__icon md-icon"></span>
</label>
</div>
<nav aria-label="ChapterI" class="md-nav" data-md-level="3">
<label class="md-nav__title" for="__nav_3_2_3">
<span class="md-nav__icon md-icon"></span>
          ChapterI
        </label>
<ul class="md-nav__list" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link" href="../../math/AbstractAlgebra/ChapterI/Lec1/">
        1.1 群定义 循环群
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../math/AbstractAlgebra/ChapterI/Lec2/">
        1.2 同态与同构 陪集 正规子群与商群
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../math/AbstractAlgebra/ChapterI/Lec3/">
        1.3 对称群 交错群 二面体群
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../math/AbstractAlgebra/ChapterI/Lec4/">
        1.4 阿贝尔群
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../math/AbstractAlgebra/ChapterI/Lec5/">
        1.5 群作用
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../math/AbstractAlgebra/ChapterI/Lec6/">
        1.6 Sylow 定理 有限群分类
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../math/AbstractAlgebra/ChapterI/Lec7/">
        1.7 幂零群和可解群 正规列和次正规列
      </a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item md-nav__item--nested">
<input class="md-nav__toggle md-toggle" data-md-toggle="__nav_3_2_4" id="__nav_3_2_4" type="checkbox"/>
<div class="md-nav__link md-nav__link--index">
<a href="../../math/AbstractAlgebra/ChapterII/">ChapterII</a>
<label for="__nav_3_2_4">
<span class="md-nav__icon md-icon"></span>
</label>
</div>
<nav aria-label="ChapterII" class="md-nav" data-md-level="3">
<label class="md-nav__title" for="__nav_3_2_4">
<span class="md-nav__icon md-icon"></span>
          ChapterII
        </label>
<ul class="md-nav__list" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link" href="../../math/AbstractAlgebra/ChapterII/Lec1/">
        2.1 环基本定义
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../math/AbstractAlgebra/ChapterII/Lec2/">
        2.2 理想
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../math/AbstractAlgebra/ChapterII/Lec3/">
        2.3 交换环上的因子分解
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../math/AbstractAlgebra/ChapterII/Lec4/">
        2.4 分式环 局部化
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../math/AbstractAlgebra/ChapterII/Lec5/">
        2.5 多项式环 形式幂级数
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../math/AbstractAlgebra/ChapterII/Lec6/">
        2.6 多项式环上的分解
      </a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item md-nav__item--nested">
<input class="md-nav__toggle md-toggle" data-md-toggle="__nav_3_2_5" id="__nav_3_2_5" type="checkbox"/>
<div class="md-nav__link md-nav__link--index">
<a href="../../math/AbstractAlgebra/ChapterIII/">ChapterIII</a>
<label for="__nav_3_2_5">
<span class="md-nav__icon md-icon"></span>
</label>
</div>
<nav aria-label="ChapterIII" class="md-nav" data-md-level="3">
<label class="md-nav__title" for="__nav_3_2_5">
<span class="md-nav__icon md-icon"></span>
          ChapterIII
        </label>
<ul class="md-nav__list" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link" href="../../math/AbstractAlgebra/ChapterIII/Lec1/">
        3.1 模 模同态 正合列
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../math/AbstractAlgebra/ChapterIII/Lec2/">
        3.2 自由模和向量空间
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../math/AbstractAlgebra/ChapterIII/Lec3/">
        3.3 投射摸和内射模
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../math/AbstractAlgebra/ChapterIII/Lec4/">
        3.4 Hom 和 Tensor
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../math/AbstractAlgebra/ChapterIII/Lec5/">
        3.5 主理想整环上的有限生成模
      </a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item md-nav__item--nested">
<input class="md-nav__toggle md-toggle" data-md-toggle="__nav_3_2_6" id="__nav_3_2_6" type="checkbox"/>
<div class="md-nav__link md-nav__link--index">
<a href="../../math/AbstractAlgebra/ChapterIV/">ChapterIV</a>
<label for="__nav_3_2_6">
<span class="md-nav__icon md-icon"></span>
</label>
</div>
<nav aria-label="ChapterIV" class="md-nav" data-md-level="3">
<label class="md-nav__title" for="__nav_3_2_6">
<span class="md-nav__icon md-icon"></span>
          ChapterIV
        </label>
<ul class="md-nav__list" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link" href="../../math/AbstractAlgebra/ChapterIV/Lec1/">
        4.1 域扩张
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../math/AbstractAlgebra/ChapterIV/Lec2/">
        4.2 Galois 理论基本定理
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../math/AbstractAlgebra/ChapterIV/Lec3/">
        4.3 分裂域 代数闭包 正规性
      </a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../math/AbstractAlgebra/HW_archive/">
        Homework archive
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../math/AbstractAlgebra/Final/">
        Final Exam
      </a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item md-nav__item--nested">
<input class="md-nav__toggle md-toggle" data-md-toggle="__nav_3_3" id="__nav_3_3" type="checkbox"/>
<div class="md-nav__link md-nav__link--index">
<a href="../../math/NumberTheory/">NumberTheory</a>
<label for="__nav_3_3">
<span class="md-nav__icon md-icon"></span>
</label>
</div>
<nav aria-label="NumberTheory" class="md-nav" data-md-level="2">
<label class="md-nav__title" for="__nav_3_3">
<span class="md-nav__icon md-icon"></span>
          NumberTheory
        </label>
<ul class="md-nav__list" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link" href="../../math/NumberTheory/Lec1/">
        1 Euclidean Algorithm and Factorization
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../math/NumberTheory/Lec2/">
        2 Modular Arithmetic
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../math/NumberTheory/Lec3/">
        3 Some Diophantine Equations
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../math/NumberTheory/Lec4/">
        4 Order of units &amp; Application in cryptography
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../math/NumberTheory/Lec5/">
        5 Sum of Two Squares
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../math/NumberTheory/Lec6/">
        6 Quadratic Reciprocity Law
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../math/NumberTheory/Lec7/">
        7 Sum of Four Squares
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../math/NumberTheory/Lec8/">
        8 Quadratic Gauss Sum
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../math/NumberTheory/Lec9/">
        9 Pell's Equation
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../math/NumberTheory/Lec10/">
        10 Factorization in Quadratic Fields
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../math/NumberTheory/Lec11/">
        11 Primes of Arithmetic Progression
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../math/NumberTheory/Lec12/">
        12 Sum of Three Squares
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../math/NumberTheory/Lec13/">
        13 Congruent Number
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../math/NumberTheory/HW_archive/">
        Homework archive
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../math/NumberTheory/Final/">
        Final Exam
      </a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item md-nav__item--nested">
<input class="md-nav__toggle md-toggle" data-md-toggle="__nav_3_4" id="__nav_3_4" type="checkbox"/>
<div class="md-nav__link md-nav__link--index">
<a href="../../math/AlgebraicNumberTheory/">AlgebraicNumberTheory</a>
<label for="__nav_3_4">
<span class="md-nav__icon md-icon"></span>
</label>
</div>
<nav aria-label="AlgebraicNumberTheory" class="md-nav" data-md-level="2">
<label class="md-nav__title" for="__nav_3_4">
<span class="md-nav__icon md-icon"></span>
          AlgebraicNumberTheory
        </label>
<ul class="md-nav__list" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link" href="../../math/AlgebraicNumberTheory/Lec1/">
        1 Integrality
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../math/AlgebraicNumberTheory/Lec2/">
        2 Norm, Trace, Discriminant
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../math/AlgebraicNumberTheory/Lec3/">
        3 Dedekind Domains
      </a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item md-nav__item--nested">
<input class="md-nav__toggle md-toggle" data-md-toggle="__nav_3_5" id="__nav_3_5" type="checkbox"/>
<div class="md-nav__link md-nav__link--index">
<a href="../../math/FunctionalAnalysis/">FunctionalAnalysis</a>
<label for="__nav_3_5">
<span class="md-nav__icon md-icon"></span>
</label>
</div>
<nav aria-label="FunctionalAnalysis" class="md-nav" data-md-level="2">
<label class="md-nav__title" for="__nav_3_5">
<span class="md-nav__icon md-icon"></span>
          FunctionalAnalysis
        </label>
<ul class="md-nav__list" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link" href="../../math/FunctionalAnalysis/Lec1/">
        1 Metric Space
      </a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item md-nav__item--nested">
<input class="md-nav__toggle md-toggle" data-md-toggle="__nav_3_6" id="__nav_3_6" type="checkbox"/>
<div class="md-nav__link md-nav__link--index">
<a href="../../math/DGC/">DGC</a>
</div>
<nav aria-label="DGC" class="md-nav" data-md-level="2">
<label class="md-nav__title" for="__nav_3_6">
<span class="md-nav__icon md-icon"></span>
          DGC
        </label>
<ul class="md-nav__list" data-md-scrollfix="">
</ul>
</nav>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item md-nav__item--nested">
<input class="md-nav__toggle md-toggle" data-md-toggle="__nav_4" id="__nav_4" type="checkbox"/>
<div class="md-nav__link md-nav__link--index">
<a href="../../crypto/">Crypto</a>
<label for="__nav_4">
<span class="md-nav__icon md-icon"></span>
</label>
</div>
<nav aria-label="Crypto" class="md-nav" data-md-level="1">
<label class="md-nav__title" for="__nav_4">
<span class="md-nav__icon md-icon"></span>
          Crypto
        </label>
<ul class="md-nav__list" data-md-scrollfix="">
<li class="md-nav__item md-nav__item--nested">
<input class="md-nav__toggle md-toggle" data-md-toggle="__nav_4_2" id="__nav_4_2" type="checkbox"/>
<div class="md-nav__link md-nav__link--index">
<a href="../../crypto/ModernCryptoBasic/">Modern Cryptography Basic</a>
<label for="__nav_4_2">
<span class="md-nav__icon md-icon"></span>
</label>
</div>
<nav aria-label="Modern Cryptography Basic" class="md-nav" data-md-level="2">
<label class="md-nav__title" for="__nav_4_2">
<span class="md-nav__icon md-icon"></span>
          Modern Cryptography Basic
        </label>
<ul class="md-nav__list" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link" href="../../crypto/ModernCryptoBasic/Lec1/">
        1 Defining Security
      </a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../crypto/ECC/">
        ECC
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../crypto/ABY/">
        ABY Protocol
      </a>
</li>
<li class="md-nav__item md-nav__item--nested">
<input class="md-nav__toggle md-toggle" data-md-toggle="__nav_4_5" id="__nav_4_5" type="checkbox"/>
<div class="md-nav__link md-nav__link--index">
<a href="../../crypto/Lattice/">Lattice</a>
<label for="__nav_4_5">
<span class="md-nav__icon md-icon"></span>
</label>
</div>
<nav aria-label="Lattice" class="md-nav" data-md-level="2">
<label class="md-nav__title" for="__nav_4_5">
<span class="md-nav__icon md-icon"></span>
          Lattice
        </label>
<ul class="md-nav__list" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link" href="../../crypto/Lattice/Lec1/">
        1 基本概念
      </a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item md-nav__item--nested">
<input class="md-nav__toggle md-toggle" data-md-toggle="__nav_4_6" id="__nav_4_6" type="checkbox"/>
<div class="md-nav__link md-nav__link--index">
<a href="../../crypto/RSA/">RSA</a>
<label for="__nav_4_6">
<span class="md-nav__icon md-icon"></span>
</label>
</div>
<nav aria-label="RSA" class="md-nav" data-md-level="2">
<label class="md-nav__title" for="__nav_4_6">
<span class="md-nav__icon md-icon"></span>
          RSA
        </label>
<ul class="md-nav__list" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link" href="../../crypto/RSA/Lec1/">
        Misc
      </a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item md-nav__item--nested">
<input class="md-nav__toggle md-toggle" data-md-toggle="__nav_4_7" id="__nav_4_7" type="checkbox"/>
<div class="md-nav__link md-nav__link--index">
<a href="../../crypto/PRNG/">PRNG</a>
<label for="__nav_4_7">
<span class="md-nav__icon md-icon"></span>
</label>
</div>
<nav aria-label="PRNG" class="md-nav" data-md-level="2">
<label class="md-nav__title" for="__nav_4_7">
<span class="md-nav__icon md-icon"></span>
          PRNG
        </label>
<ul class="md-nav__list" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link" href="../../crypto/PRNG/LCG/">
        线性同余生成器
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../crypto/PRNG/MT_19937/">
        MT19937
      </a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item md-nav__item--nested">
<input class="md-nav__toggle md-toggle" data-md-toggle="__nav_4_8" id="__nav_4_8" type="checkbox"/>
<div class="md-nav__link md-nav__link--index">
<a href="../../crypto/HE/">Homomorphic Encryption</a>
<label for="__nav_4_8">
<span class="md-nav__icon md-icon"></span>
</label>
</div>
<nav aria-label="Homomorphic Encryption" class="md-nav" data-md-level="2">
<label class="md-nav__title" for="__nav_4_8">
<span class="md-nav__icon md-icon"></span>
          Homomorphic Encryption
        </label>
<ul class="md-nav__list" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link" href="../../crypto/HE/Lec1/">
        1 定义
      </a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item md-nav__item--nested">
<input class="md-nav__toggle md-toggle" data-md-toggle="__nav_4_9" id="__nav_4_9" type="checkbox"/>
<div class="md-nav__link md-nav__link--index">
<a href="../../crypto/sage/">sage</a>
</div>
<nav aria-label="sage" class="md-nav" data-md-level="2">
<label class="md-nav__title" for="__nav_4_9">
<span class="md-nav__icon md-icon"></span>
          sage
        </label>
<ul class="md-nav__list" data-md-scrollfix="">
</ul>
</nav>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item md-nav__item--active md-nav__item--nested">
<input checked="" class="md-nav__toggle md-toggle" data-md-toggle="__nav_5" id="__nav_5" type="checkbox"/>
<div class="md-nav__link md-nav__link--index">
<a href="../">Papers</a>
<label for="__nav_5">
<span class="md-nav__icon md-icon"></span>
</label>
</div>
<nav aria-label="Papers" class="md-nav" data-md-level="1">
<label class="md-nav__title" for="__nav_5">
<span class="md-nav__icon md-icon"></span>
          Papers
        </label>
<ul class="md-nav__list" data-md-scrollfix="">
<li class="md-nav__item md-nav__item--active">
<input class="md-nav__toggle md-toggle" data-md-toggle="toc" id="__toc" type="checkbox"/>
<label class="md-nav__link md-nav__link--active" for="__toc">
          Random Oracles in a Quantum World
          <span class="md-nav__icon md-icon"></span>
</label>
<a class="md-nav__link md-nav__link--active" href="./">
        Random Oracles in a Quantum World
      </a>
<nav aria-label="目录" class="md-nav md-nav--secondary">
<label class="md-nav__title" for="__toc">
<span class="md-nav__icon md-icon"></span>
      目录
    </label>
<ul class="md-nav__list" data-md-component="toc" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link" href="#preliminaries">
    Preliminaries
  </a>
<nav aria-label="Preliminaries" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#quantum-computation">
    Quantum Computation
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#quantum-accessible-random-oracles">
    Quantum-Accessible Random Oracles
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#hard-problems-for-quantum-computers">
    Hard Problems for Quantum Computers
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#cryptographic-primitives">
    Cryptographic Primitives
  </a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#separation-result">
    Separation Result
  </a>
<nav aria-label="Separation Result" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#preliminaries_1">
    Preliminaries
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#construction">
    Construction
  </a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#signature-schemes-in-the-quantum-accessible-random-oracle-model">
    Signature Schemes in the Quantum-Accessible Random Oracle Model
  </a>
<nav aria-label="Signature Schemes in the Quantum-Accessible Random Oracle Model" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#secure-signatures-from-preimage-sampleable-trapdoor-functions-psf">
    Secure Signatures From Preimage Sampleable Trapdoor Functions (PSF)
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#secure-signatures-from-claw-free-permutations">
    Secure Signatures from Claw-Free Permutations
  </a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#encryption-schemes-in-the-quantum-accessible-random-oracle-model">
    Encryption Schemes in the Quantum-Accessible Random Oracle Model
  </a>
<nav aria-label="Encryption Schemes in the Quantum-Accessible Random Oracle Model" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#cpa-security-of-br-encryption">
    CPA Security of BR Encryption
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#cca-security-of-hybrid-encryption">
    CCA Security of Hybrid Encryption
  </a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#appendix">
    Appendix
  </a>
<nav aria-label="Appendix" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#definition">
    Definition
  </a>
</li>
</ul>
</nav>
</li>
</ul>
</nav>
</li>
</ul>
</nav>
</li>
</ul>
</nav>
</div>
</div>
</div>
<div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc">
<div class="md-sidebar__scrollwrap">
<div class="md-sidebar__inner">
<nav aria-label="目录" class="md-nav md-nav--secondary">
<label class="md-nav__title" for="__toc">
<span class="md-nav__icon md-icon"></span>
      目录
    </label>
<ul class="md-nav__list" data-md-component="toc" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link" href="#preliminaries">
    Preliminaries
  </a>
<nav aria-label="Preliminaries" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#quantum-computation">
    Quantum Computation
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#quantum-accessible-random-oracles">
    Quantum-Accessible Random Oracles
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#hard-problems-for-quantum-computers">
    Hard Problems for Quantum Computers
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#cryptographic-primitives">
    Cryptographic Primitives
  </a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#separation-result">
    Separation Result
  </a>
<nav aria-label="Separation Result" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#preliminaries_1">
    Preliminaries
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#construction">
    Construction
  </a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#signature-schemes-in-the-quantum-accessible-random-oracle-model">
    Signature Schemes in the Quantum-Accessible Random Oracle Model
  </a>
<nav aria-label="Signature Schemes in the Quantum-Accessible Random Oracle Model" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#secure-signatures-from-preimage-sampleable-trapdoor-functions-psf">
    Secure Signatures From Preimage Sampleable Trapdoor Functions (PSF)
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#secure-signatures-from-claw-free-permutations">
    Secure Signatures from Claw-Free Permutations
  </a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#encryption-schemes-in-the-quantum-accessible-random-oracle-model">
    Encryption Schemes in the Quantum-Accessible Random Oracle Model
  </a>
<nav aria-label="Encryption Schemes in the Quantum-Accessible Random Oracle Model" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#cpa-security-of-br-encryption">
    CPA Security of BR Encryption
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#cca-security-of-hybrid-encryption">
    CCA Security of Hybrid Encryption
  </a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#appendix">
    Appendix
  </a>
<nav aria-label="Appendix" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#definition">
    Definition
  </a>
</li>
</ul>
</nav>
</li>
</ul>
</nav>
</div>
</div>
</div>
<div class="md-content" data-md-component="content">
<article class="md-content__inner md-typeset">
<h1 id="random-oracles-in-a-quantum-world">Random Oracles in a Quantum World<a class="headerlink" href="#random-oracles-in-a-quantum-world" title="Permanent link">¶</a></h1>
<div class="admonition info">
<p class="admonition-title">Abstract</p>
<ul>
<li>
<p>原文链接：<a href="https://eprint.iacr.org/2010/428.pdf">Random Oracles in a Quantum World</a></p>
</li>
<li>
<p>只对论文主体部分以及影响理解的部分进行了翻译，摘要，介绍，总结等部分未翻译<span><span class="heti-spacing"> </span>.</span></p>
</li>
<li>
<p>整体思路为给出分离结果，构建无历史规约，运用无历史规约证明签名方案的安全性，最后对部分加密方案安全性进行证明<span><span class="heti-spacing"> </span>.</span></p>
</li>
</ul>
</div>
<h2 id="preliminaries">Preliminaries<a class="headerlink" href="#preliminaries" title="Permanent link">¶</a></h2>
<p>一非负函数<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\varepsilon = \varepsilon(n)\)</span><span class="heti-spacing"> </span></span>是一个<strong>可忽略<span><span class="heti-spacing"> </span>(negligible)</span></strong>函数，如果对于所有的多项式<span><span class="heti-spacing"> </span><span class="arithmatex">\(p(n)\)</span></span>，存在一个<span><span class="heti-spacing"> </span><span class="arithmatex">\(N\)</span></span>，使得对于所有的<span><span class="heti-spacing"> </span><span class="arithmatex">\(n &gt; N\)</span></span>，有<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\varepsilon(n) &lt; p(n)^{-1}\)</span>.<span class="heti-spacing"> </span></span>而对于<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\Omega\)</span><span class="heti-spacing"> </span></span>上的两个分布<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(D_1\)</span><span class="heti-spacing"> </span></span>和<span><span class="heti-spacing"> </span><span class="arithmatex">\(D_2\)</span></span>，二者之间的<strong>变差距离<span><span class="heti-spacing"> </span>(variational distance)</span></strong>定义为</p>
<div class="arithmatex">\[
    \abs{D_1 - D_2} = \sum_{x \in \Omega} \abs{\Pr{x \mid D_1} - \Pr{x \mid D_2}}
\]</div>
<p>如果两个分布之间的距离为<span><span class="heti-spacing"> </span><span class="arithmatex">\(\varepsilon\)</span></span>，那么二者关于输出满足某种特定性质的概率之差不会超过<span><span class="heti-spacing"> </span><span class="arithmatex">\(\varepsilon\)</span>.</span></p>
<p>一个经典的随机算法<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(A\)</span><span class="heti-spacing"> </span></span>可以用如下两种方式去运用：</p>
<ol>
<li>
<p><span><span class="arithmatex">\(A\)</span><span class="heti-spacing"> </span></span>被给定输入<span><span class="heti-spacing"> </span><span class="arithmatex">\(x\)</span></span>，并在计算中进行一些随机处理（如掷硬币<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>，最终输出一个结果<span><span class="heti-spacing"> </span><span class="arithmatex">\(y\)</span></span>，记作<span><span class="heti-spacing"> </span><span class="arithmatex">\(A(x)\)</span></span>，其为一个随机变量<span><span class="heti-spacing"> </span>.</span></p>
</li>
<li>
<p><span><span class="arithmatex">\(A\)</span><span class="heti-spacing"> </span></span>被给定输入<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(x\)</span><span class="heti-spacing"> </span></span>和随机值<span><span class="heti-spacing"> </span><span class="arithmatex">\(r\)</span></span>，并输出一个结果<span><span class="heti-spacing"> </span><span class="arithmatex">\(y\)</span></span>，记作<span><span class="heti-spacing"> </span><span class="arithmatex">\(A(x; r)\)</span></span>，其为一个确定值<span><span class="heti-spacing"> </span>.</span></p>
</li>
</ol>
<p>算法<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(A\)</span><span class="heti-spacing"> </span></span>被认为是<span class="heti-skip"><span class="heti-spacing"> </span>Probabilistic Polynomial Time (<span class="arithmatex">\(\op{PPT}\)</span>)<span class="heti-spacing"> </span></span>的，如果其在<span class="heti-skip"><span class="heti-spacing"> </span>security parameter<span class="heti-spacing"> </span></span>上运行的时间是多项式的<span><span class="heti-spacing"> </span>.</span></p>
<h3 id="quantum-computation">Quantum Computation<a class="headerlink" href="#quantum-computation" title="Permanent link">¶</a></h3>
<p>一个量子系统<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(A\)</span><span class="heti-spacing"> </span></span>是与一个有限维复<span class="heti-skip"><span class="heti-spacing"> </span>Hilbert<span class="heti-spacing"> </span></span>空间<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\mathcal{H}_A\)</span><span class="heti-spacing"> </span></span>相关联的，其上的内积为<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\innerproduct{\cdot}{\cdot}\)</span>.<span class="heti-spacing"> </span></span>系统的状态向量可以用<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\ket{\varphi} \in \mathcal{H}_A\)</span><span class="heti-spacing"> </span></span>表示，其满足欧几里得范数<span><span class="heti-spacing"> </span><span class="arithmatex">\(\norm{\ket{\varphi}} = \sqrt{\innerproduct{\varphi}{\varphi}} = 1\)</span>.</span></p>
<p>给定量子系统<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(A\)</span><span class="heti-spacing"> </span></span>和<span><span class="heti-spacing"> </span><span class="arithmatex">\(B\)</span></span>，其<span class="heti-skip"><span class="heti-spacing"> </span>Hilbert<span class="heti-spacing"> </span></span>空间分别为<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\mathcal{H}_A\)</span><span class="heti-spacing"> </span></span>和<span><span class="heti-spacing"> </span><span class="arithmatex">\(\mathcal{H}_B\)</span></span>，则<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(A\)</span><span class="heti-spacing"> </span></span>和<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(B\)</span><span class="heti-spacing"> </span></span>的<strong>复合</strong>是通过张量积<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\otimes\)</span><span class="heti-spacing"> </span></span>定义的，空间为<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\mathcal{H}_A \otimes \mathcal{H}_B\)</span>.<span class="heti-spacing"> </span></span>对于两个态<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\ket{\varphi_A} \in \mathcal{H}_A\)</span><span class="heti-spacing"> </span></span>和<span><span class="heti-spacing"> </span><span class="arithmatex">\(\ket{\varphi_B} \in \mathcal{H}_B\)</span></span>，其复合态为<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\ket{\varphi_A} \otimes \ket{\varphi_B} \in \mathcal{H}_A \otimes \mathcal{H}_B\)</span>.<span class="heti-spacing"> </span></span>一个<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(n\)</span><span class="heti-spacing"> </span></span>量子比特系统的<span class="heti-skip"><span class="heti-spacing"> </span>Hilbert<span class="heti-spacing"> </span></span>空间是建立在<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(n\)</span><span class="heti-spacing"> </span></span>个二维复<span class="heti-skip"><span class="heti-spacing"> </span>Hilbert<span class="heti-spacing"> </span></span>空间的复合上的，对于这样的系统，其标准正交计算基<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\ket{x}\)</span><span class="heti-spacing"> </span></span>由<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\ket{x_1} \otimes \cdots \otimes \ket{x_n}\)</span><span class="heti-spacing"> </span></span>给出，其中<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(x = x_1 \cdots x_n\)</span><span class="heti-spacing"> </span></span>是一个<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(n\)</span><span class="heti-spacing"> </span></span>位二进制串<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>任意一个二进制串都可以编码为一个态<span><span class="heti-spacing"> </span><span class="arithmatex">\(\ket{x}\)</span></span>，而任意的<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(n\)</span><span class="heti-spacing"> </span></span>量子比特的纯态都可以用计算基表示为<span><span class="heti-spacing"> </span><span class="arithmatex">\(\ket{\varphi} = \sum_{x \in \{0, 1\}^n} \alpha_x \ket{x}\)</span></span>，其中<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\alpha_x\)</span><span class="heti-spacing"> </span></span>为复振幅满足<span><span class="heti-spacing"> </span><span class="arithmatex">\(\sum_{x \in \{0, 1\}^n} \abs{\alpha_x}^2 = 1\)</span>.</span></p>
<p>而量子系统的变化都是通过酉变换描述的<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>记<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\mathbb{I}_A\)</span><span class="heti-spacing"> </span></span>为系统<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(A\)</span><span class="heti-spacing"> </span></span>上的恒等变换<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>对于复合量子系统<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\mathcal{H}_A \otimes \mathcal{H}_B\)</span><span class="heti-spacing"> </span></span>以及<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\mathcal{H}_A\)</span><span class="heti-spacing"> </span></span>上的酉变换<span><span class="heti-spacing"> </span><span class="arithmatex">\(U_A\)</span></span>，<span><span class="arithmatex">\(U_A \ket{\varphi_A} \ket{\varphi_B}\)</span><span class="heti-spacing"> </span></span>实际上表示<span><span class="heti-spacing"> </span><span class="arithmatex">\((U_A \otimes \mathbb{I}_B) \ket{\varphi_A} \ket{\varphi_B}\)</span>.</span></p>
<p>信息的提取依靠的是对量子态<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\ket{\varphi}\)</span><span class="heti-spacing"> </span></span>进行测量，其中一种测量方式称为<span class="heti-skip"><span class="heti-spacing"> </span>POVM (Positive Operator-Valued Measure).<span class="heti-spacing"> </span></span>一个<span class="heti-skip"><span class="heti-spacing"> </span>POVM <span class="arithmatex">\(M = \{M_i\}\)</span><span class="heti-spacing"> </span></span>是一组半正定测量算子，满足和为恒等算子，即<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\sum_i M_i = \mathbb{I}\)</span>.<span class="heti-spacing"> </span></span>结果<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(i\)</span><span class="heti-spacing"> </span></span>的概率为<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(p_i = \bra{\varphi} M_i \ket{\varphi}\)</span>.<span class="heti-spacing"> </span></span>特殊的例子是投影测量，量子态满足<span><span class="heti-spacing"> </span><span class="arithmatex">\(\ket{\varphi} = \sum_x \alpha_x \ket{x}\)</span></span>，结果为<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(x\)</span><span class="heti-spacing"> </span></span>的概率为<span><span class="heti-spacing"> </span><span class="arithmatex">\(\abs{\alpha_x}^2\)</span>.</span></p>
<p>同样，也可以只对量子态的部分位进行测量，但直接计算得到的量子态的范数不为<span><span class="heti-spacing"> </span>1</span>，所以需要规范化<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>比如考虑测量<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\ket{\psi} = \sum_{x, y} \alpha_{x, y} \ket{x, y}\)</span><span class="heti-spacing"> </span></span>的前<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(n\)</span><span class="heti-spacing"> </span></span>位，那么得到结果<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(x\)</span><span class="heti-spacing"> </span></span>的概率便是<span><span class="heti-spacing"> </span><span class="arithmatex">\(\sum_{y'} \abs{\alpha_{x, y'}}^2\)</span></span>，而规范化后的态为</p>
<div class="arithmatex">\[
    \ket{x} \sum_y \frac{\alpha_{x, y}}{\sqrt{\sum_{y'} \abs{\alpha_{x, y'}}^2}} \ket{y}
\]</div>
<p>此外，也需要对量子攻击者<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\mathcal{A}_Q\)</span><span class="heti-spacing"> </span></span>进行建模，方法是通过一系列在<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(k = \poly{n}\)</span><span class="heti-spacing"> </span></span>个量子比特上的酉变换<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(U_1, O_1, U_2, O_2, \ldots, O_{T - 1}, U_T\)</span><span class="heti-spacing"> </span></span>来描述其行为，该攻击者能够访问的<span class="heti-skip"><span class="heti-spacing"> </span>Oracles<span class="heti-spacing"> </span></span>为<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(O_1, O_2, \ldots\)</span>.<span class="heti-spacing"> </span></span>这些<span class="heti-skip"><span class="heti-spacing"> </span>Oracles<span class="heti-spacing"> </span></span>满足<span><span class="heti-spacing"> </span><span class="arithmatex">\(O_i: \{0, 1\}^n \to \{0, 1\}^m\)</span></span>，并且将前<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(n + m\)</span><span class="heti-spacing"> </span></span>位的输入从基态<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\ket{x}\ket{y}\)</span><span class="heti-spacing"> </span></span>映射到<span><span class="heti-spacing"> </span><span class="arithmatex">\(\ket{x}\ket{y \oplus O_i(x)}\)</span></span>，<span class="arithmatex">\(\ket{x} \in \{0, 1\}^n\)</span>，<span><span class="arithmatex">\(\ket{y} \in \{0, 1\}^m\)</span>.<span class="heti-spacing"> </span></span>如果希望对<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(O_i\)</span><span class="heti-spacing"> </span></span>的查询是经典的，那么只需要在施加相应于<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(O_i\)</span><span class="heti-spacing"> </span></span>的酉变换之前对输入进行测量即可<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>此外，也经常用<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\mathcal{A}_Q^{\ket{O_1(\cdot)}, \ket{O_2(\cdot)}, \ldots}\)</span><span class="heti-spacing"> </span></span>符号来表示这些<span class="heti-skip"><span class="heti-spacing"> </span>Oracles<span class="heti-spacing"> </span></span>是量子可访问的<span><span class="heti-spacing"> </span>.</span></p>
<p>为了引进渐进分析，假定<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\mathcal{A}_Q\)</span><span class="heti-spacing"> </span></span>是一系列酉变换的序列，由参数<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(n\)</span><span class="heti-spacing"> </span></span>索引，并且每个酉变换序列由输入、输出、<span>Oracles<span class="heti-spacing"> </span></span>调用以及工作空间的量子系统组成<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>而为了衡量多项式运行时间，假定<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(U_i\)</span><span class="heti-spacing"> </span></span>都可以用一组通用门以足够的精度进行近似，而且这些通用门的数量是多项式的<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>此外，<span><span class="arithmatex">\(T = T(n)\)</span><span class="heti-spacing"> </span></span>也是多项式的<span><span class="heti-spacing"> </span>.</span></p>
<p>定义量子态之间的欧式距离为<span><span class="heti-spacing"> </span><span class="arithmatex">\(\abs{\ket{\varphi} - \ket{\psi}} = \left( \sum_x \abs{\alpha_x - \beta_x}^2 \right)^{1/2}\)</span></span>，其中<span><span class="heti-spacing"> </span><span class="arithmatex">\(\ket{\varphi} = \sum_x \alpha_x \ket{x}\)</span></span>，<span><span class="arithmatex">\(\ket{\psi} = \sum_x \beta_x \ket{x}\)</span>.<span class="heti-spacing"> </span></span>定义<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(q_r(\ket{\varphi_t})\)</span><span class="heti-spacing"> </span></span>为第<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(t\)</span><span class="heti-spacing"> </span></span>次查询的叠加态中<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(r\)</span><span class="heti-spacing"> </span></span>的振幅的平方，也被称为第<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(t\)</span><span class="heti-spacing"> </span></span>次查询中<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(r\)</span><span class="heti-spacing"> </span></span>的查询概率<span><span class="heti-spacing"> </span>.</span></p>
<div class="admonition success">
<p class="admonition-title">Lemma</p>
<p>设量子态<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\ket{\varphi}\)</span><span class="heti-spacing"> </span></span>和<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\ket{\psi}\)</span><span class="heti-spacing"> </span></span>之间的欧式距离至多为<span><span class="heti-spacing"> </span><span class="arithmatex">\(\varepsilon\)</span></span>，则在二者上进行相同的测量，得到的分布之间的统计距离至多为<span><span class="heti-spacing"> </span><span class="arithmatex">\(4 \varepsilon\)</span>.</span></p>
</div>
<div class="admonition success">
<p class="admonition-title">Lemma</p>
<p>设<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(A_Q\)</span><span class="heti-spacing"> </span></span>是一个运行时间为<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T\)</span><span class="heti-spacing"> </span></span>且可访问<span class="heti-skip"><span class="heti-spacing"> </span>Oracle<span class="heti-spacing"> </span></span>为<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(O\)</span><span class="heti-spacing"> </span></span>的量子算法<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>设<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\varepsilon &gt; 0\)</span><span class="heti-spacing"> </span></span>且<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(S \subset [1, T] \times \{0, 1\}^n\)</span><span class="heti-spacing"> </span></span>是一个时间<span class="heti-skip"><span class="heti-spacing"> </span>-<span class="heti-spacing"> </span></span>字符串对的集合，满足</p>
<div class="arithmatex">\[
    \sum_{(t, r) \in S} q_r(\ket{\psi_t}) \leq \varepsilon.
\]</div>
<p>如果将<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(O\)</span><span class="heti-spacing"> </span></span>修改为<span><span class="heti-spacing"> </span><span class="arithmatex">\(O'\)</span></span>，使得其在时间<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(t\)</span><span class="heti-spacing"> </span></span>时查询<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(r\)</span><span class="heti-spacing"> </span></span>的回复都是一个相同的随机独立采样的字符串<span><span class="heti-spacing"> </span><span class="arithmatex">\(R\)</span></span>，那么<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(A_Q\)</span><span class="heti-spacing"> </span></span>分别调用<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(O\)</span><span class="heti-spacing"> </span></span>和<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(O'\)</span><span class="heti-spacing"> </span></span>的最终状态之间的欧式距离至多为<span><span class="heti-spacing"> </span><span class="arithmatex">\(\sqrt{T \varepsilon}\)</span>.</span></p>
</div>
<h3 id="quantum-accessible-random-oracles">Quantum-Accessible Random Oracles<a class="headerlink" href="#quantum-accessible-random-oracles" title="Permanent link">¶</a></h3>
<div class="admonition info">
<p class="admonition-title">Definition</p>
<p><strong>(Pseudorandom Function)</strong> 一个量子可访问的伪随机函数是一个可以高效计算的函数<span><span class="heti-spacing"> </span><span class="arithmatex">\(\PRF\)</span></span>，满足对于所有高效的量子算法<span><span class="heti-spacing"> </span><span class="arithmatex">\(D\)</span></span>，有</p>
<div class="arithmatex">\[
    \abs{\Pr{D^{\PRF(k, \cdot)}(1^n) = 1} - \Pr{D^{O(\cdot)}(1^n) = 1}} &lt; \varepsilon,
\]</div>
<p>其中<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\varepsilon = \varepsilon(n)\)</span><span class="heti-spacing"> </span></span>是一个可忽略函数，<span><span class="arithmatex">\(O\)</span><span class="heti-spacing"> </span></span>是一个随机<span class="heti-skip"><span class="heti-spacing"> </span>Oracle.<span class="heti-spacing"> </span></span>第一个概率是分布在长度为<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(n\)</span><span class="heti-spacing"> </span></span>的密钥<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(k\)</span><span class="heti-spacing"> </span></span>上的，第二个概率是分布在所有随机<span class="heti-skip"><span class="heti-spacing"> </span>Oracles<span class="heti-spacing"> </span></span>和<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(D\)</span><span class="heti-spacing"> </span></span>的输出的采样上的<span><span class="heti-spacing"> </span>.</span></p>
</div>
<p>称一<span class="heti-skip"><span class="heti-spacing"> </span>Oracle <span class="arithmatex">\(O'\)</span><span class="heti-spacing"> </span></span>与一个随机<span class="heti-skip"><span class="heti-spacing"> </span>Oracle <span class="arithmatex">\(O\)</span><span class="heti-spacing"> </span></span>是<strong>计算上不可区分的<span><span class="heti-spacing"> </span>(computationally indistinguishable)</span></strong>，如果对于所有的可访问<span class="heti-skip"><span class="heti-spacing"> </span>Oracle<span class="heti-spacing"> </span></span>的多项式时间量子算法<span><span class="heti-spacing"> </span><span class="arithmatex">\(D\)</span></span>，当<span class="heti-skip"><span class="heti-spacing"> </span>Oracle<span class="heti-spacing"> </span></span>为<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(O'\)</span><span class="heti-spacing"> </span></span>的输出分布与<span class="heti-skip"><span class="heti-spacing"> </span>Oracle<span class="heti-spacing"> </span></span>为<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(O\)</span><span class="heti-spacing"> </span></span>的输出分布之间的变差距离是可忽略的<span><span class="heti-spacing"> </span>.</span></p>
<h3 id="hard-problems-for-quantum-computers">Hard Problems for Quantum Computers<a class="headerlink" href="#hard-problems-for-quantum-computers" title="Permanent link">¶</a></h3>
<div class="admonition info">
<p class="admonition-title">Definition</p>
<p><strong>(Problem)</strong> 一个问题是一个二元组<span><span class="heti-spacing"> </span><span class="arithmatex">\(P = (\op{Game}_P, \alpha_P)\)</span></span>，其中<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\op{Game}_P\)</span><span class="heti-spacing"> </span></span>描述了一个<span><span class="heti-spacing"> </span>Game</span>，其敌手可能是量子的而挑战者是经典的<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>这一<span class="heti-skip"><span class="heti-spacing"> </span>Game<span class="heti-spacing"> </span></span>按如下规则进行：</p>
<ul>
<li>
<p>输入<span><span class="heti-spacing"> </span><span class="arithmatex">\(1^n\)</span></span>，挑战者计算出一个值<span><span class="heti-spacing"> </span><span class="arithmatex">\(x\)</span></span>，并将其发送给敌手，作为输入；</p>
</li>
<li>
<p>敌手以<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(x\)</span><span class="heti-spacing"> </span></span>为输入运行，并且允许向挑战者进行经典查询；</p>
</li>
<li>
<p>敌手输出一个值<span><span class="heti-spacing"> </span><span class="arithmatex">\(y\)</span></span>，并将其发送给挑战者；</p>
</li>
<li>
<p>挑战者根据<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(x\)</span><span class="heti-spacing"> </span></span>和<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(y\)</span><span class="heti-spacing"> </span></span>以及敌手进行的经典查询，输出一个比特<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(1\)</span><span class="heti-spacing"> </span></span>或<span><span class="heti-spacing"> </span><span class="arithmatex">\(0\)</span>.</span></p>
</li>
</ul>
<p><span><span class="arithmatex">\(\alpha_P\)</span><span class="heti-spacing"> </span></span>是一个<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\([0, 1)\)</span><span class="heti-spacing"> </span></span>上的实数，其有可能是<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(n\)</span><span class="heti-spacing"> </span></span>的一个函数，但此处只需要常数<span><span class="heti-spacing"> </span><span class="arithmatex">\(\alpha_P\)</span></span>，具体来说<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\alpha_P\)</span><span class="heti-spacing"> </span></span>总是<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(0\)</span><span class="heti-spacing"> </span></span>或<span><span class="heti-spacing"> </span><span class="arithmatex">\(\frac{1}{2}\)</span>.</span></p>
</div>
<p>称敌手<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(A\)</span><span class="heti-spacing"> </span></span>赢得了<span><span class="heti-spacing"> </span>Game <span class="arithmatex">\(\op{Game}_P\)</span></span>，如果挑战者输出了<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(1\)</span>.<span class="heti-spacing"> </span></span>定义敌手<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(A\)</span><span class="heti-spacing"> </span></span>在问题<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(P\)</span><span class="heti-spacing"> </span></span>中的优势为</p>
<div class="arithmatex">\[
    \Adv_{A, P} = \abs{\Pr{A \text{ wins in } \op{Game}_P} - \alpha_P}.
\]</div>
<div class="admonition info">
<p class="admonition-title">Definition</p>
<p><strong>(Hard Problem)</strong> 一个问题<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(P = (\op{Game}_P, \alpha_P)\)</span><span class="heti-spacing"> </span></span>对量子计算机是困难的，如果对于所有的多项式时间量子敌手<span><span class="heti-spacing"> </span><span class="arithmatex">\(A\)</span></span>，其优势<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\Adv_{A, P}\)</span><span class="heti-spacing"> </span></span>是可忽略的<span><span class="heti-spacing"> </span>.</span></p>
</div>
<h3 id="cryptographic-primitives">Cryptographic Primitives<a class="headerlink" href="#cryptographic-primitives" title="Permanent link">¶</a></h3>
<p>一个陷门函数<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\mathcal{F}\)</span><span class="heti-spacing"> </span></span>是安全的，如果<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\op{Inv}(\mathcal{F}) = (\op{Game}_{\op{Inv}}(\mathcal{F}), 0)\)</span><span class="heti-spacing"> </span></span>对量子计算机是困难的<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>其中在<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\op{Game}_{\op{Inv}}\)</span><span class="heti-spacing"> </span></span>中，敌手被给出了一个随机元素<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(y\)</span><span class="heti-spacing"> </span></span>和公钥，若其能够给出<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(y\)</span><span class="heti-spacing"> </span></span>关于公钥的逆便算成功<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>而对于原像可采样陷门函数<span><span class="heti-spacing"> </span>(Preimage Sampleable Trapdoor Function) <span class="arithmatex">\(\mathcal{F}\)</span></span>，其安全性不仅需要<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\op{Inv}(\mathcal{F})\)</span><span class="heti-spacing"> </span></span>是困难的，还需要<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\op{Col}(\mathcal{F}) = (\op{Game}_{\op{Col}}(\mathcal{F}), 0)\)</span><span class="heti-spacing"> </span></span>是困难的<span class="heti-skip"><span class="heti-spacing"> </span>. <span class="arithmatex">\(\op{Game}_{\op{Col}}\)</span><span class="heti-spacing"> </span></span>给出了公钥，敌手需要输出两个不同的<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(x_1\)</span><span class="heti-spacing"> </span></span>和<span><span class="heti-spacing"> </span><span class="arithmatex">\(x_2\)</span></span>，使得<span><span class="heti-spacing"> </span><span class="arithmatex">\(\mathcal{F}(x_1) = \mathcal{F}(x_2)\)</span></span>，即找到了一个碰撞<span><span class="heti-spacing"> </span>.</span></p>
<p>对于签名方案<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\mathcal{S}\)</span><span class="heti-spacing"> </span></span>而言，其安全性需要满足<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\op{Sig-Forge}(\mathcal{S}) = (\op{Game}_{\op{Sig}}(\mathcal{S}), 0)\)</span><span class="heti-spacing"> </span></span>是困难的<span class="heti-skip"><span class="heti-spacing"> </span>. <span class="arithmatex">\(\op{Game}_{\op{Sig}}\)</span><span class="heti-spacing"> </span></span>是在选择明文攻击下的标准存在不可伪造性博弈<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>最后，对于私钥（公钥）加密方案<span><span class="heti-spacing"> </span><span class="arithmatex">\(\mathcal{E}\)</span></span>，如果<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\op{Sym-CCA}(\mathcal{E}) = (\op{Game}_{\op{Sym}}(\mathcal{E}), \frac{1}{2})\)</span> (<span class="arithmatex">\(\op{ASym-CCA}(\mathcal{E}) = (\op{Game}_{\op{ASym}}(\mathcal{E}), \frac{1}{2})\)</span>)<span class="heti-spacing"> </span></span>是困难的，那么称其是安全的，其中<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\op{Game}_{\op{Sym}}\)</span> (<span class="arithmatex">\(\op{Game}_{\op{ASym}}\)</span>)<span class="heti-spacing"> </span></span>是标准的私钥（公钥）选择密文攻击博弈<span><span class="heti-spacing"> </span>.</span></p>
<details class="tip">
<summary><a href="https://crypto.stackexchange.com/questions/91489/what-does-existential-unforgeability-mean-in-a-digital-signature-scheme">What does existential unforgeability mean in a digital signature scheme?</a></summary>
<p><em>"Existential unforgeability" alone means adversaries can't create signatures that verify for messages they have not already a signature for. Strictly speaking, breaking existential unforgeability may only mean adversaries end up with a message and signature that verify, but the message is gibberish void of any use for the adversaries.</em></p>
<p><em>There is also "strong existential unforgeability", which additionally means adversaries can't create new signatures that verify, against any message.</em></p>
</details>
<h2 id="separation-result">Separation Result<a class="headerlink" href="#separation-result" title="Permanent link">¶</a></h2>
<h3 id="preliminaries_1">Preliminaries<a class="headerlink" href="#preliminaries_1" title="Permanent link">¶</a></h3>
<ul>
<li>
<p><strong>身份验证方案（Identification Scheme）</strong>：身份验证方案<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\op{IS}\)</span><span class="heti-spacing"> </span></span>是一个三元组<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\((\op{IS}.\mathsf{KGen}, \mathcal{P}, \mathcal{V})\)</span>.<span class="heti-spacing"> </span></span>其中<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\op{IS}.\mathsf{KGen}\)</span><span class="heti-spacing"> </span></span>输入<span><span class="heti-spacing"> </span><span class="arithmatex">\(1^n\)</span></span>，输出一个密钥对<span><span class="heti-spacing"> </span><span class="arithmatex">\((\sk, \pk)\)</span></span>；<span><span class="arithmatex">\(\mathcal{P}(\sk, \pk)\)</span><span class="heti-spacing"> </span></span>和<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\mathcal{V}(\pk)\)</span><span class="heti-spacing"> </span></span>定义了证明者<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\mathcal{P}\)</span><span class="heti-spacing"> </span></span>和验证者<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\mathcal{V}\)</span><span class="heti-spacing"> </span></span>之间的交互式协议，最终<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\mathcal{V}\)</span><span class="heti-spacing"> </span></span>输出<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(1\)</span><span class="heti-spacing"> </span></span>或<span><span class="heti-spacing"> </span><span class="arithmatex">\(0\)</span></span>，表示验证成功或失败<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>假定这个协议是完备的，即对于所有诚实的证明者<span><span class="heti-spacing"> </span><span class="arithmatex">\(\mathcal{P}\)</span></span>，验证者<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\mathcal{V}\)</span><span class="heti-spacing"> </span></span>总是接受<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>而其安全性证明则是考虑敌手<span><span class="heti-spacing"> </span><span class="arithmatex">\(\mathcal{A}\)</span></span>，一阶段先和<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\mathcal{P}\)</span><span class="heti-spacing"> </span></span>交互，获取<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\sk\)</span><span class="heti-spacing"> </span></span>的信息，然后在第二阶段与<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\mathcal{V}\)</span><span class="heti-spacing"> </span></span>交互，使得其输出<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(1\)</span>.<span class="heti-spacing"> </span></span>如果敌手能让<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\mathcal{V}\)</span><span class="heti-spacing"> </span></span>输出<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(1\)</span><span class="heti-spacing"> </span></span>的概率是可忽略的，那么称<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\op{IS}\)</span><span class="heti-spacing"> </span></span>是可靠的（sound）.</p>
</li>
<li>
<p><strong>（近似）碰撞抗性哈希函数（(Near-) Collision-Resistant Hash Function）</strong>： 哈希函数<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\op{H} = (\op{H}.\mathsf{KGen}, \op{H}.\mathsf{Eval})\)</span><span class="heti-spacing"> </span></span>是一对高效的算法，满足<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\op{H}.\mathsf{KGen}(1^n)\)</span><span class="heti-spacing"> </span></span>输出一个密钥<span><span class="heti-spacing"> </span><span class="arithmatex">\(k\)</span></span>，<span><span class="arithmatex">\(\op{H}.\mathsf{Eval}\)</span><span class="heti-spacing"> </span></span>以<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(k\)</span><span class="heti-spacing"> </span></span>和<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(M \in \{0, 1\}^*\)</span><span class="heti-spacing"> </span></span>为输入，确定性地输出一个摘要（digest）<span><span class="arithmatex">\(h = \op{H}.\mathsf{Eval}(k, M)\)</span>.<span class="heti-spacing"> </span></span>对于随机<span><span class="heti-spacing"> </span>Oracle <span class="arithmatex">\(H\)</span></span>，<span><span class="arithmatex">\(k\)</span><span class="heti-spacing"> </span></span>被用作“盐”，并且常考虑<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(H(k, \cdot)\)</span><span class="heti-spacing"> </span></span>这一随机函数<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>而近似碰撞抗性哈希函数则需要满足对任意高效的算法<span><span class="heti-spacing"> </span><span class="arithmatex">\(\mathcal{A}\)</span></span>，<span class="arithmatex">\(k \from \op{H}.\mathsf{KGen}(1^n)\)</span>，某常数<span><span class="heti-spacing"> </span><span class="arithmatex">\(1 \leq l \leq n\)</span></span>，有</p>
<div class="arithmatex">\[\begin{gather*}
    (M, M') \from \mathcal{A}(k, l) \\
    M \neq M' \land \op{H}.\mathsf{Eval}(k, M) \mid_{l} = \op{H}.\mathsf{Eval}(k, M') \mid_{l}
\end{gather*}\]</div>
<p>的概率是可忽略的<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>这里的<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(x \mid_l\)</span><span class="heti-spacing"> </span></span>表示<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(x\)</span><span class="heti-spacing"> </span></span>的前<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(l\)</span><span class="heti-spacing"> </span></span>位<span><span class="heti-spacing"> </span>.</span> </p>
<p>在经典情况下，任意哈希函数的（近似）碰撞抗性都被生日攻击所约束<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>生日攻击阐明对任意<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(n\)</span><span class="heti-spacing"> </span></span>位输出的哈希函数，攻击者在尝试<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(2^{n/2}\)</span><span class="heti-spacing"> </span></span>次互异且随机的输入后，有大约<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(1/2\)</span><span class="heti-spacing"> </span></span>的概率找到碰撞<span><span class="heti-spacing"> </span>.</span> </p>
</li>
<li>
<p><strong><span>Grover<span class="heti-spacing"> </span></span>算法和量子碰撞搜索（Grover's Algorithm and Quantum Collision Search）</strong>：<span>Grover<span class="heti-spacing"> </span></span>算法在未结构化的<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(N\)</span><span class="heti-spacing"> </span></span>个元素的数据库上进行搜索，其时间复杂度为<span><span class="heti-spacing"> </span><span class="arithmatex">\(O(\sqrt{N})\)</span></span>，而最优的经典算法的时间复杂度为<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(O(N)\)</span>.<span class="heti-spacing"> </span></span>粗略地说，这是依靠的是叠加态能够在同一时间检查所有条目<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>这一思路也同样可以用于检索哈希函数的碰撞<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>考虑<span><span class="heti-spacing"> </span><span class="arithmatex">\(H: \{0, 1\}^* \to \{0, 1\}^n\)</span></span>，首先选择<span><span class="heti-spacing"> </span><span class="arithmatex">\(K \subset \{0, 1\}^*\)</span></span>，然后在一指示函数<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(f\)</span><span class="heti-spacing"> </span></span>上运用<span class="heti-skip"><span class="heti-spacing"> </span>Grover<span class="heti-spacing"> </span></span>算法，来检查对于任意输入<span><span class="heti-spacing"> </span><span class="arithmatex">\(M \in \{0, 1\}^* \setminus K\)</span></span>，是否存在<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(M' \in K\)</span><span class="heti-spacing"> </span></span>使得<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(H(M) = H(M')\)</span>.<span class="heti-spacing"> </span></span>通过设置<span><span class="heti-spacing"> </span><span class="arithmatex">\(\abs{K} = \sqrt[3]{2^n}\)</span></span>，该算法可以在<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(O(\sqrt[3]{2^n})\)</span><span class="heti-spacing"> </span></span>时间内以至少<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(1/2\)</span><span class="heti-spacing"> </span></span>的概率找到碰撞<span><span class="heti-spacing"> </span>.</span></p>
</li>
<li>
<p><strong>计算与时间假设（Computational and Timing Assumptions）</strong>：此处对敌手的计算能力和量子计算机与经典计算机的时间流逝进行规范<span><span class="heti-spacing"> </span>.</span></p>
<ol>
<li>
<p>要求并行计算得到的加速比是被一个固定项所约束的<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>换言之，不可能无限加速<span><span class="heti-spacing"> </span>.</span> </p>
<div class="admonition success">
<p class="admonition-title">Assumption</p>
<p><strong>(Parallel Speed-Up)</strong> 记<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T(C)\)</span><span class="heti-spacing"> </span></span>为经典计算机解决问题<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(C\)</span><span class="heti-spacing"> </span></span>所需的时间，<span><span class="arithmatex">\(T_P(C)\)</span><span class="heti-spacing"> </span></span>为并行计算机解决问题<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(C\)</span><span class="heti-spacing"> </span></span>所需的时间<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>那么存在常数<span><span class="heti-spacing"> </span><span class="arithmatex">\(\alpha \geq 1\)</span></span>，使得对于所有问题<span><span class="heti-spacing"> </span><span class="arithmatex">\(C\)</span></span>，有<span><span class="heti-spacing"> </span><span class="arithmatex">\(T_P(C) \geq T(C) / \alpha\)</span>.</span></p>
</div>
</li>
<li>
<p>以下两个假设是关于哈希函数的计算与两方通信的时间流逝的<span><span class="heti-spacing"> </span>.</span> </p>
<div class="admonition success">
<p class="admonition-title">Assumption</p>
<p><strong>(Unit Time)</strong> 对任意哈希函数<span><span class="heti-spacing"> </span><span class="arithmatex">\(H\)</span></span>，和任意输入<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(M\)</span>(<span class="arithmatex">\(M_Q\)</span><span class="heti-spacing"> </span></span>用作量子态输入<span><span class="heti-spacing"> </span>)</span>，<span><span class="arithmatex">\(H(M)\)</span><span class="heti-spacing"> </span></span>的计算需要一个恒定的时间，满足<span><span class="heti-spacing"> </span><span class="arithmatex">\(T(H(M)) = T_P(H(M)) = T_Q(H(M_Q))\)</span></span>，其中<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_P\)</span><span class="heti-spacing"> </span></span>和<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_Q\)</span><span class="heti-spacing"> </span></span>分别是并行计算机和量子计算机的计算时间<span><span class="heti-spacing"> </span>.</span> </p>
</div>
<div class="admonition success">
<p class="admonition-title">Assumption</p>
<p><strong>(Zero Time)</strong> 任何不涉及哈希函数计算的计算或动作都是瞬时完成的<span><span class="heti-spacing"> </span>.</span></p>
</div>
<p>后者阐明量子计算机可能在其他方面获得的计算优势与哈希函数的计算时间相比是可忽略的<span><span class="heti-spacing"> </span>.</span></p>
</li>
</ol>
</li>
</ul>
<h3 id="construction">Construction<a class="headerlink" href="#construction" title="Permanent link">¶</a></h3>
<p>开始构建证明者<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\mathcal{P}\)</span><span class="heti-spacing"> </span></span>和验证者<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\mathcal{V}\)</span><span class="heti-spacing"> </span></span>之间的身份验证方案<span><span class="heti-spacing"> </span><span class="arithmatex">\(\op{IS}\)</span></span>，主要思想是通过增加一个哈希函数的碰撞发现阶段来增强其安全性<span><span class="heti-spacing"> </span>.</span> </p>
<ol>
<li>
<p>验证者检查证明者能否在特定的时间内产生哈希函数的碰撞<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>更具体而言，验证者对消息<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\langle c \rangle\)</span><span class="heti-spacing"> </span></span>计算哈希函数<span><span class="heti-spacing"> </span><span class="arithmatex">\(\op{H}.\mathsf{Eval}(k, \cdot)\)</span></span>，并进行计时，其中<span><span class="heti-spacing"> </span><span class="arithmatex">\(c = 1, 2, \ldots, \lceil \sqrt[3]{2^l} \rceil\)</span></span>，并且<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\langle c \rangle\)</span><span class="heti-spacing"> </span></span>是<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(c\)</span><span class="heti-spacing"> </span></span>的二进制表示，长度为<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\log \lceil \sqrt[3]{2^l} \rceil\)</span><span class="heti-spacing"> </span></span>位<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>证明者需要回复一个近似碰撞，即<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(M \neq M'\)</span><span class="heti-spacing"> </span></span>但<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\op{H}.\mathsf{Eval}(k, M) \mid_l = \op{H}.\mathsf{Eval}(k, M') \mid_l\)</span>.<span class="heti-spacing"> </span></span>如果验证者收到了这样的一个碰撞，或是<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\sqrt[3]{2^l}\)</span><span class="heti-spacing"> </span></span>次哈希函数计算完成，则碰撞阶段结束<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>验证者和证明者随后重复<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(r = \poly{n}\)</span><span class="heti-spacing"> </span></span>次这一过程，并且每次验证者都会选择一个新的密钥<span><span class="heti-spacing"> </span><span class="arithmatex">\(k\)</span>.</span></p>
</li>
<li>
<p>随后，两方按照标准的身份验证方案进行交互<span><span class="heti-spacing"> </span>.</span> </p>
</li>
<li>
<p>最后，如果证明者能够找到足够多的碰撞，或者在标准的身份验证方案中成功，那么验证者接受<span><span class="heti-spacing"> </span>.</span></p>
</li>
</ol>
<p>该协议<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\op{IS}^*\)</span><span class="heti-spacing"> </span></span>的完备性可自然地从<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\op{IS}\)</span><span class="heti-spacing"> </span></span>的完备性推导出来<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>而其安全性则需要针对经典敌手和量子敌手分别进行分析<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>证明过程即敌手<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\mathcal{A}\)</span><span class="heti-spacing"> </span></span>与诚实的证明者<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\mathcal{P}^*\)</span><span class="heti-spacing"> </span></span>交互后，并不能够冒充<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\mathcal{P}^*\)</span><span class="heti-spacing"> </span></span>通过<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\mathcal{V}^*\)</span><span class="heti-spacing"> </span></span>的验证<span><span class="heti-spacing"> </span>.</span></p>
<p>设<span><span class="heti-spacing"> </span><span class="arithmatex">\(l &gt; 6\log(\alpha)\)</span></span>，其中<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\alpha\)</span><span class="heti-spacing"> </span></span>是并行假设中的常数<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>通过假定<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\op{IS}\)</span><span class="heti-spacing"> </span></span>是一个量子免疫身份验证方案，便可以证明<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\op{IS}^*\)</span><span class="heti-spacing"> </span></span>在标准的随机<span class="heti-skip"><span class="heti-spacing"> </span>Oracle<span class="heti-spacing"> </span></span>模型下是安全的，无论是对于经典敌手还是量子敌手<span><span class="heti-spacing"> </span>.</span> </p>
<p>主要的想法在于对于随机<span class="heti-skip"><span class="heti-spacing"> </span>Oracle<span class="heti-spacing"> </span></span>模型，碰撞搜索的能力还是被生日攻击所约束的<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>因为限制了搜索时间为<span><span class="heti-spacing"> </span><span class="arithmatex">\(O(\sqrt[3]{2^k})\)</span></span>，并且有<span><span class="heti-spacing"> </span><span class="arithmatex">\(l &gt; 6\log(\alpha)\)</span></span>，所以即便敌手拥有量子或并行的计算能力，也不可能进行至少<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\sqrt{2^l}\)</span><span class="heti-spacing"> </span></span>次的随机<span class="heti-skip"><span class="heti-spacing"> </span>Oracle<span class="heti-spacing"> </span></span>访问<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>因而，<span><span class="arithmatex">\(\mathcal{A}\)</span><span class="heti-spacing"> </span></span>能够在<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(r\)</span><span class="heti-spacing"> </span></span>轮中找到至少<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(1/4\)</span><span class="heti-spacing"> </span></span>的碰撞的概率是可忽略的<span><span class="heti-spacing"> </span>.</span></p>
<p>对于经典敌手<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\mathcal{A}\)</span><span class="heti-spacing"> </span></span>而言，这样的一个随机<span class="heti-skip"><span class="heti-spacing"> </span>Oracle<span class="heti-spacing"> </span></span>是可以实例化的，只需要利用接近于生日攻击约束上界的近似碰撞抗性哈希函数<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(H\)</span><span class="heti-spacing"> </span></span>即可<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>但对量子敌手<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\mathcal{A}_Q\)</span><span class="heti-spacing"> </span></span>而言，这样的哈希函数实例化是不存在的，因为<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\mathcal{A}_Q\)</span><span class="heti-spacing"> </span></span>可以在本地应用<span class="heti-skip"><span class="heti-spacing"> </span>Grover<span class="heti-spacing"> </span></span>算法来找到碰撞，并且在<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\sqrt[3]{2^l}\)</span><span class="heti-spacing"> </span></span>时间内找到碰撞的概率至少为<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(1/2\)</span>.<span class="heti-spacing"> </span></span>而对于有量子可访问随机<span class="heti-skip"><span class="heti-spacing"> </span>Oracle<span class="heti-spacing"> </span></span>的敌手而言，这也是不安全的，因为<span class="heti-skip"><span class="heti-spacing"> </span>Grover<span class="heti-spacing"> </span></span>算法只要求对哈希函数的黑箱访问<span><span class="heti-spacing"> </span>.</span></p>
<h2 id="signature-schemes-in-the-quantum-accessible-random-oracle-model">Signature Schemes in the Quantum-Accessible Random Oracle Model<a class="headerlink" href="#signature-schemes-in-the-quantum-accessible-random-oracle-model" title="Permanent link">¶</a></h2>
<p>接下来给出的是经典随机<span class="heti-skip"><span class="heti-spacing"> </span>Oracle<span class="heti-spacing"> </span></span>安全性转化为量子可访问随机<span class="heti-skip"><span class="heti-spacing"> </span>Oracle<span class="heti-spacing"> </span></span>安全性的条件，被称为<strong>无历史规约（history-free reduction）</strong>，具体而言，<span>Oracle<span class="heti-spacing"> </span></span>对于查询的回复与先前的查询以及查询序号无关<span><span class="heti-spacing"> </span>.</span></p>
<div class="admonition info">
<p class="admonition-title">Definition</p>
<p><strong>(History-Free Reduction)</strong> 如果一个随机<span class="heti-skip"><span class="heti-spacing"> </span>Oracle<span class="heti-spacing"> </span></span>签名方案<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\mathcal{S} = (G, S^O, V^O)\)</span><span class="heti-spacing"> </span></span>存在安全性证明使用<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\mathcal{S}\)</span><span class="heti-spacing"> </span></span>的经典<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\op{PPT}\)</span><span class="heti-spacing"> </span></span>敌手<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(A\)</span><span class="heti-spacing"> </span></span>为困难问题<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(P = (\op{Game}_P, 0)\)</span><span class="heti-spacing"> </span></span>构建经典<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\op{PPT}\)</span><span class="heti-spacing"> </span></span>算法<span><span class="heti-spacing"> </span><span class="arithmatex">\(B\)</span></span>，且满足以下条件：</p>
<ul>
<li>
<p><span><span class="arithmatex">\(B\)</span><span class="heti-spacing"> </span></span>包含四部分经典算法：<span><span class="arithmatex">\(\op{START}\)</span>, <span class="arithmatex">\(\op{RAND}^{O_C}\)</span>, <span class="arithmatex">\(\op{SIGN}^{O_C}\)</span><span class="heti-spacing"> </span></span>和<span><span class="heti-spacing"> </span><span class="arithmatex">\(\op{FINISH}^{O_C}\)</span></span>，后三者可以共享访问一个经典的随机<span class="heti-skip"><span class="heti-spacing"> </span>Oracle <span class="arithmatex">\(O_C\)</span>.<span class="heti-spacing"> </span></span>除去<span><span class="heti-spacing"> </span><span class="arithmatex">\(\op{RAND}^{O_C}\)</span></span>，其余算法可以向问题<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(P\)</span><span class="heti-spacing"> </span></span>的挑战者发送查询<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>以下是算法的应用规则：</p>
<ol>
<li>
<p>给定问题<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(P\)</span><span class="heti-spacing"> </span></span>的一个实例<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(x\)</span><span class="heti-spacing"> </span></span>作为输入，算法<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(B\)</span><span class="heti-spacing"> </span></span>首先运行<span><span class="heti-spacing"> </span><span class="arithmatex">\(\op{START}(x)\)</span></span>，来获取<span><span class="heti-spacing"> </span><span class="arithmatex">\((\pk, z)\)</span></span>，其中<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\pk\)</span><span class="heti-spacing"> </span></span>是公钥，<span><span class="arithmatex">\(z\)</span><span class="heti-spacing"> </span></span>是一个可供<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(B\)</span><span class="heti-spacing"> </span></span>使用的私有态<span class="heti-skip"><span class="heti-spacing"> </span>. <span class="arithmatex">\(B\)</span><span class="heti-spacing"> </span></span>将<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\pk\)</span><span class="heti-spacing"> </span></span>发送给<span><span class="heti-spacing"> </span><span class="arithmatex">\(A\)</span></span>，并扮演挑战者的角色<span><span class="heti-spacing"> </span>.</span></p>
</li>
<li>
<p>当<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(A\)</span><span class="heti-spacing"> </span></span>向<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(O(r)\)</span><span class="heti-spacing"> </span></span>发送经典随机<span class="heti-skip"><span class="heti-spacing"> </span>Oracle<span class="heti-spacing"> </span></span>查询时，<span><span class="arithmatex">\(B\)</span><span class="heti-spacing"> </span></span>会调用<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\op{RAND}^{O_C}(r, z)\)</span><span class="heti-spacing"> </span></span>来获取回复<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>注意<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\op{RAND}\)</span><span class="heti-spacing"> </span></span>只使用当前查询作为输入，对先前的查询和回复无感知<span><span class="heti-spacing"> </span>.</span></p>
</li>
<li>
<p>当<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(A\)</span><span class="heti-spacing"> </span></span>发出经典签名查询<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(S(\sk, m)\)</span><span class="heti-spacing"> </span></span>时，<span><span class="arithmatex">\(B\)</span><span class="heti-spacing"> </span></span>会调用<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\op{SIGN}^{O_C}(m, z)\)</span><span class="heti-spacing"> </span></span>来获取签名并回复给<span><span class="heti-spacing"> </span><span class="arithmatex">\(A\)</span>.</span></p>
</li>
<li>
<p>当<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(A\)</span><span class="heti-spacing"> </span></span>输出一个可能的伪造签名<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\((m, \sigma)\)</span><span class="heti-spacing"> </span></span>时，<span><span class="arithmatex">\(B\)</span><span class="heti-spacing"> </span></span>输出<span><span class="heti-spacing"> </span><span class="arithmatex">\(\op{FINISH}^{O_C}(m, \sigma, z)\)</span>.</span></p>
</li>
</ol>
</li>
<li>
<p>存在高效的可计算函数<span><span class="heti-spacing"> </span><span class="arithmatex">\(\op{INSTANCE}(\pk)\)</span></span>，能够给出问题<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(P\)</span><span class="heti-spacing"> </span></span>的实例<span><span class="heti-spacing"> </span><span class="arithmatex">\(x\)</span></span>，并且存在<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(z\)</span><span class="heti-spacing"> </span></span>使得<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\op{START}(x) = (\pk, z)\)</span>.<span class="heti-spacing"> </span></span>考虑整个过程，首先利用<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(G(1^n)\)</span><span class="heti-spacing"> </span></span>生成<span><span class="heti-spacing"> </span><span class="arithmatex">\((\pk, \sk)\)</span></span>，然后运行<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\op{INSTANCE}(\pk)\)</span><span class="heti-spacing"> </span></span>来获取<span><span class="heti-spacing"> </span><span class="arithmatex">\(x\)</span></span>，这样生成的<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(x\)</span><span class="heti-spacing"> </span></span>的分布与<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\op{Game}_P\)</span><span class="heti-spacing"> </span></span>生成的<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(x\)</span><span class="heti-spacing"> </span></span>的分布之间的变差距离是可忽略的<span><span class="heti-spacing"> </span>.</span></p>
</li>
<li>
<p>对固定的<span><span class="heti-spacing"> </span><span class="arithmatex">\(z\)</span></span>，考虑经典随机<span><span class="heti-spacing"> </span>Oracle <span class="arithmatex">\(O(r) = \op{RAND}^{O_C}(r, z)\)</span></span>，定义一个量子<span><span class="heti-spacing"> </span>Oracle <span class="arithmatex">\(O_{\op{quant}}\)</span></span>，由<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\ket{x, y} \mapsto \ket{x, y \oplus O(x)}\)</span><span class="heti-spacing"> </span></span>给出，要求其与随机<span class="heti-skip"><span class="heti-spacing"> </span>Oracle<span class="heti-spacing"> </span></span>是量子计算上不可区分的<span><span class="heti-spacing"> </span>.</span></p>
</li>
<li>
<p><span><span class="arithmatex">\(\op{SIGN}^{O_C}\)</span><span class="heti-spacing"> </span></span>要么中止（因而使得<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(B\)</span><span class="heti-spacing"> </span></span>中止<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>，要么输出一个关于<span class="heti-skip"><span class="heti-spacing"> </span>Oracle <span class="arithmatex">\(O(r) = \op{RAND}^{O_C}(r, z)\)</span><span class="heti-spacing"> </span></span>的有效签名，并且其分布与正确的签名分布之间的变差距离是可忽略的，并且需要没有任何一个签名查询中止的概率是不可忽略的<span><span class="heti-spacing"> </span>.</span></p>
</li>
<li>
<p>如果<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\((m, \sigma)\)</span><span class="heti-spacing"> </span></span>是一个关于公钥<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\pk\)</span><span class="heti-spacing"> </span></span>和<span class="heti-skip"><span class="heti-spacing"> </span>Oracle <span class="arithmatex">\(O(r) = \op{RAND}^{O_C}(r, z)\)</span><span class="heti-spacing"> </span></span>有效的伪造签名，那么<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(B\)</span><span class="heti-spacing"> </span></span>的输出，即<span><span class="heti-spacing"> </span><span class="arithmatex">\(\op{FINISH}^{O_C}(m, \sigma, z)\)</span></span>，使得<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(P\)</span><span class="heti-spacing"> </span></span>的挑战者输出<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(1\)</span><span class="heti-spacing"> </span></span>的概率是不可忽略的<span><span class="heti-spacing"> </span>.</span></p>
</li>
</ul>
<p>那么称<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\mathcal{S}\)</span><span class="heti-spacing"> </span></span>存在一个无历史规约<span><span class="heti-spacing"> </span>.</span></p>
</div>
<p>下面给出无历史规约推出量子安全性的定理<span><span class="heti-spacing"> </span>.</span></p>
<div class="admonition note">
<p class="admonition-title">Theorem</p>
<p>设<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\mathcal{S} = (G, S, V)\)</span><span class="heti-spacing"> </span></span>是一个签名方案，其存在一个无历史规约<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>若问题<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(P\)</span><span class="heti-spacing"> </span></span>对于多项式量子计算机是困难的，且量子可访问伪随机函数是存在的，那么<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\mathcal{S}\)</span><span class="heti-spacing"> </span></span>在量子可访问随机<span class="heti-skip"><span class="heti-spacing"> </span>Oracle<span class="heti-spacing"> </span></span>模型下是安全的<span><span class="heti-spacing"> </span>.</span></p>
<details class="note" open="open">
<summary>Proof</summary>
<p>使用一系列的<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\op{Game}\)</span><span class="heti-spacing"> </span></span>进行证明<span><span class="heti-spacing"> </span>.</span></p>
<ul>
<li>
<p><strong>Game 0</strong>：定义<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\op{Game}_0\)</span><span class="heti-spacing"> </span></span>为量子敌手<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(A_Q\)</span><span class="heti-spacing"> </span></span>在问题<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\op{Sig-Forge}(\mathcal{S})\)</span><span class="heti-spacing"> </span></span>上的博弈<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>为了制造反例，假定<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(A_Q\)</span><span class="heti-spacing"> </span></span>的优势是不可忽略的<span><span class="heti-spacing"> </span>.</span></p>
</li>
<li>
<p><strong>Game 1</strong>：在<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\op{Game}_0\)</span><span class="heti-spacing"> </span></span>上进行修改，定义<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\op{Game}_1\)</span>.<span class="heti-spacing"> </span></span>要求挑战者生成<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\((\sk, \pk)\)</span><span class="heti-spacing"> </span></span>后，计算出<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(x \from \op{INSTANCE}(\pk)\)</span><span class="heti-spacing"> </span></span>以及<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\((\pk, z) \from \op{START}(x)\)</span>.<span class="heti-spacing"> </span></span>并且，当<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(A_Q\)</span><span class="heti-spacing"> </span></span>向量子随机<span class="heti-skip"><span class="heti-spacing"> </span>Oracle<span class="heti-spacing"> </span></span>发送查询时，改为使用量子可访问随机<span class="heti-skip"><span class="heti-spacing"> </span>Oracle <span class="arithmatex">\(O_{\op{quant}}\)</span><span class="heti-spacing"> </span></span>进行模拟<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>其将<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\ket{x, y}\)</span><span class="heti-spacing"> </span></span>映射到<span><span class="heti-spacing"> </span><span class="arithmatex">\(\ket{x, y \oplus \op{RAND}^{O_q}(x, z)}\)</span></span>，其中<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(O_q\)</span><span class="heti-spacing"> </span></span>是一个真正的量子可访问随机<span class="heti-skip"><span class="heti-spacing"> </span>Oracle.<span class="heti-spacing"> </span></span>因为无历史规约保证了<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(O_{\op{quant}}\)</span><span class="heti-spacing"> </span></span>对于量子敌手而言是计算上不可区分的，也就是说，<span><span class="arithmatex">\(A_Q\)</span><span class="heti-spacing"> </span></span>在<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\op{Game}_1\)</span><span class="heti-spacing"> </span></span>上获胜的概率与其在<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\op{Game}_0\)</span><span class="heti-spacing"> </span></span>上获胜的概率的差距是可忽略的，从而整个概率是不可忽略的<span><span class="heti-spacing"> </span>.</span></p>
</li>
<li>
<p><strong>Game 2</strong>：在<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\op{Game}_1\)</span><span class="heti-spacing"> </span></span>上进行修改，<span><span class="arithmatex">\(\op{Game}_2\)</span><span class="heti-spacing"> </span></span>不再自行生成<span><span class="heti-spacing"> </span><span class="arithmatex">\((\sk, \pk)\)</span></span>，以及计算<span><span class="heti-spacing"> </span><span class="arithmatex">\(x \from \op{INSTANCE}(\pk)\)</span></span>，而是通过运行问题<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(P\)</span><span class="heti-spacing"> </span></span>的挑战者开始，当其发送<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(x\)</span><span class="heti-spacing"> </span></span>后，便运行<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\op{Game}_1\)</span><span class="heti-spacing"> </span></span>的挑战者，以<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(x\)</span><span class="heti-spacing"> </span></span>作为输入<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>并且，当<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(A_Q\)</span><span class="heti-spacing"> </span></span>查询<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(m\)</span><span class="heti-spacing"> </span></span>的签名时，使用<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\op{SIGN}^{O_q}(m, z)\)</span><span class="heti-spacing"> </span></span>进行回复<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>因为<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\op{INSTANCE}\)</span><span class="heti-spacing"> </span></span>本身是无历史规约的一部分，<span><span class="arithmatex">\(x\)</span><span class="heti-spacing"> </span></span>的计算方法的改变带来的分布变化是可忽略的<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>而后，只要所有的签名算法都成功了，那么如何回复签名查询是无关紧要的<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>所以，<span><span class="arithmatex">\(A_Q\)</span><span class="heti-spacing"> </span></span>成功的概率是以下两个概率之乘积：</p>
<ul>
<li>
<p>所有签名都成功回复，没有中止的概率；</p>
</li>
<li>
<p>假定所有签名都成功回复，<span><span class="arithmatex">\(A_Q\)</span><span class="heti-spacing"> </span></span>能够伪造有效签名的概率<span><span class="heti-spacing"> </span>.</span></p>
</li>
</ul>
<p>根据假设，第一个概率是不可忽略的，第二个概率与<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(A_Q\)</span><span class="heti-spacing"> </span></span>在<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\op{Game}_1\)</span><span class="heti-spacing"> </span></span>上获胜的概率的差距是可忽略的，因此整个概率是不可忽略的<span><span class="heti-spacing"> </span>.</span></p>
</li>
<li>
<p><strong>Game 3</strong>：<span><span class="arithmatex">\(\op{Game}_3\)</span><span class="heti-spacing"> </span></span>在<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\op{Game}_2\)</span><span class="heti-spacing"> </span></span>上做了两处修改，一是其为量子可访问<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\PRF\)</span><span class="heti-spacing"> </span></span>生成了密钥<span><span class="heti-spacing"> </span><span class="arithmatex">\(k\)</span></span>，二为挑战者通过施加酉变换，将<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\ket{x, y}\)</span><span class="heti-spacing"> </span></span>映射到<span><span class="heti-spacing"> </span><span class="arithmatex">\(\ket{x, y \oplus \PRF(k, x)}\)</span></span>，来回复随机<span class="heti-skip"><span class="heti-spacing"> </span>Oracle<span class="heti-spacing"> </span></span>查询<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(O_q(\ket{\psi})\)</span>.<span class="heti-spacing"> </span></span>如果<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\op{Game}_3\)</span><span class="heti-spacing"> </span></span>的成功概率与<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\op{Game}_2\)</span><span class="heti-spacing"> </span></span>的成功概率的差距是不可忽略的话，那就可以为<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\PRF\)</span><span class="heti-spacing"> </span></span>构建一个区分器，其同时扮演敌手<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(A_Q\)</span><span class="heti-spacing"> </span></span>和挑战者的角色<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>所以，<span><span class="arithmatex">\(\op{Game}_3\)</span><span class="heti-spacing"> </span></span>的成功概率与<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\op{Game}_2\)</span><span class="heti-spacing"> </span></span>的成功概率的差距是可忽略的<span><span class="heti-spacing"> </span>.</span></p>
</li>
</ul>
<p>而根据<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\op{Game}_3\)</span><span class="heti-spacing"> </span></span>中拥有不可忽略的优势的量子敌手，便可以构建一个可以攻破问题<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(P\)</span><span class="heti-spacing"> </span></span>的量子算法<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(B_Q\)</span>.<span class="heti-spacing"> </span></span>当<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(B_Q\)</span><span class="heti-spacing"> </span></span>从问题<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(P\)</span><span class="heti-spacing"> </span></span>的挑战者处接收到实例<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(x\)</span><span class="heti-spacing"> </span></span>后，便可以计算出<span><span class="heti-spacing"> </span><span class="arithmatex">\((\pk, z) \from \op{START}(x)\)</span></span>，并且生成<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\PRF\)</span><span class="heti-spacing"> </span></span>的密钥<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(k\)</span>.<span class="heti-spacing"> </span></span>然后，其以<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\pk\)</span><span class="heti-spacing"> </span></span>为输入模拟<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(A_Q\)</span>. <span class="arithmatex">\(B_Q\)</span><span class="heti-spacing"> </span></span>使用<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\op{RAND}^{\PRF(k, \cdot)}\)</span><span class="heti-spacing"> </span></span>构建得到的量子可访问函数来回复随机<span class="heti-skip"><span class="heti-spacing"> </span>Oracle<span class="heti-spacing"> </span></span>查询，如同<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\op{Game}_1\)</span><span class="heti-spacing"> </span></span>中一样；至于签名查询，其使用<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\op{SIGN}^{\PRF(k, \cdot)}\)</span><span class="heti-spacing"> </span></span>来回复<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>当<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(A_Q\)</span><span class="heti-spacing"> </span></span>输出一个可能的伪造签名<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\((m, \sigma)\)</span><span class="heti-spacing"> </span></span>时，<span><span class="arithmatex">\(B_Q\)</span><span class="heti-spacing"> </span></span>输出<span><span class="heti-spacing"> </span><span class="arithmatex">\(\op{FINISH}^{\PRF(k, \cdot)}(m, \sigma, z)\)</span></span>，并将该输出返回给问题<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(P\)</span><span class="heti-spacing"> </span></span>的挑战者<span><span class="heti-spacing"> </span>.</span> </p>
<p>因为<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\op{Game}_3\)</span><span class="heti-spacing"> </span></span>中的<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(A_Q\)</span><span class="heti-spacing"> </span></span>行为和<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(B_Q\)</span><span class="heti-spacing"> </span></span>中的子例程是相同的，所以<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(A_Q\)</span><span class="heti-spacing"> </span></span>会输出一个有效的伪造签名的概率是不可忽略的<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>而一旦<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\((m, \sigma)\)</span><span class="heti-spacing"> </span></span>是有效的伪造签名，因为<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\op{FINISH}\)</span><span class="heti-spacing"> </span></span>也是无历史规约的一部分，<span><span class="arithmatex">\(\op{FINISH}^{\PRF(k, \cdot)}(m, \sigma, z)\)</span><span class="heti-spacing"> </span></span>会使得问题<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(P\)</span><span class="heti-spacing"> </span></span>的挑战者输出<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(1\)</span><span class="heti-spacing"> </span></span>的概率是不可忽略的<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>这样，<span><span class="arithmatex">\(B_Q\)</span><span class="heti-spacing"> </span></span>就成功地攻破了问题<span><span class="heti-spacing"> </span><span class="arithmatex">\(P\)</span></span>，这与问题<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(P\)</span><span class="heti-spacing"> </span></span>是困难的矛盾<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>因此，任何多项式时间的量子算法在<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\op{Sig-Forge}(\mathcal{S})\)</span><span class="heti-spacing"> </span></span>上的优势是可忽略的，从而证明了定理<span><span class="heti-spacing"> </span>.</span></p>
</details>
</div>
<h3 id="secure-signatures-from-preimage-sampleable-trapdoor-functions-psf">Secure Signatures From Preimage Sampleable Trapdoor Functions (PSF)<a class="headerlink" href="#secure-signatures-from-preimage-sampleable-trapdoor-functions-psf" title="Permanent link">¶</a></h3>
<p>下面利用无历史规约这一定理证明利用原像可采样陷门函数构建的全域哈希签名方案是安全的<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>粗略来说，<span><span class="arithmatex">\(\op{PSF}\)</span> <span class="arithmatex">\(\mathcal{F}\)</span><span class="heti-spacing"> </span></span>是一个由<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\op{PPT}\)</span><span class="heti-spacing"> </span></span>算法组成的元组<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\((G, \op{Sample}, f, f^{-1})\)</span>. <span class="arithmatex">\(G(\cdot)\)</span><span class="heti-spacing"> </span></span>生成一个密钥对<span><span class="heti-spacing"> </span><span class="arithmatex">\((\sk, \pk)\)</span></span>，<span><span class="arithmatex">\(f(\pk, \cdot)\)</span><span class="heti-spacing"> </span></span>是一个可高效计算的函数，而<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(f^{-1}(\sk, y)\)</span><span class="heti-spacing"> </span></span>从<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(y\)</span><span class="heti-spacing"> </span></span>的原像集中随机采样，<span><span class="arithmatex">\(\op{Sample}(\pk)\)</span><span class="heti-spacing"> </span></span>从<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(f(\pk, \cdot)\)</span><span class="heti-spacing"> </span></span>的定义域中随机采样得到<span><span class="heti-spacing"> </span><span class="arithmatex">\(x\)</span></span>，从而使得<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(f(\pk, x)\)</span><span class="heti-spacing"> </span></span>在<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(f(\pk, \cdot)\)</span><span class="heti-spacing"> </span></span>的值域中在统计意义上接近于均匀分布<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>这一<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\op{PSF}\)</span><span class="heti-spacing"> </span></span>不仅是单向的，同时也是具有碰撞抗性的<span><span class="heti-spacing"> </span>.</span></p>
<div class="admonition info">
<p class="admonition-title">Definition</p>
<p><strong>(Full Domain Hash)</strong> 设<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\mathcal{F} = (G, f, f^{-1})\)</span><span class="heti-spacing"> </span></span>是一个陷门置换函数，并且<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(O\)</span><span class="heti-spacing"> </span></span>是一个值域与<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(f\)</span><span class="heti-spacing"> </span></span>相同的哈希函数<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>全域哈希签名方案<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\mathcal{S} = (G, S, V)\)</span><span class="heti-spacing"> </span></span>按如下方式定义：</p>
<ul>
<li>
<p><span class="arithmatex">\(G = G_0\)</span></p>
</li>
<li>
<p><span class="arithmatex">\(S^O(\sk, m) = f^{-1}(\sk, O(m))\)</span></p>
</li>
<li>
<p><span class="arithmatex">\(V^O(\pk, m, \sigma) = \begin{cases} 1, &amp; \text{if } O(m) = f(\pk, \sigma) \\ 0, &amp; \text{otherwise} \end{cases}\)</span></p>
</li>
</ul>
</div>
<p><a href="https://eprint.iacr.org/2007/432.pdf"><span>[GPV08]<span class="heti-spacing"> </span></span></a>给出了<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\op{FDH}\)</span><span class="heti-spacing"> </span></span>签名方案可以用<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\op{PSF}\)</span><span class="heti-spacing"> </span></span>替代陷门置换函数来构建，称为<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\op{FDH-PSF}\)</span><span class="heti-spacing"> </span></span>系统<span><span class="heti-spacing"> </span>.</span></p>
<p>考虑一个从<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\op{FDH-PSF}\)</span><span class="heti-spacing"> </span></span>签名方案的经典敌手<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(A\)</span><span class="heti-spacing"> </span></span>到<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\mathcal{F}\)</span><span class="heti-spacing"> </span></span>的碰撞搜索算法<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(B\)</span><span class="heti-spacing"> </span></span>的规约：</p>
<ul>
<li>
<p>输入<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\pk\)</span><span class="heti-spacing"> </span></span>后，<span><span class="arithmatex">\(B\)</span><span class="heti-spacing"> </span></span>计算<span><span class="heti-spacing"> </span><span class="arithmatex">\(\op{START}(\pk) = (\pk, \pk)\)</span></span>，并以<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\pk\)</span><span class="heti-spacing"> </span></span>为输入模拟<span><span class="heti-spacing"> </span><span class="arithmatex">\(A\)</span>.</span></p>
</li>
<li>
<p>当<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(A\)</span><span class="heti-spacing"> </span></span>查询<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(O(r)\)</span><span class="heti-spacing"> </span></span>时，<span><span class="arithmatex">\(B\)</span><span class="heti-spacing"> </span></span>按如下计算并回复：</p>
<div class="arithmatex">\[
    \op{RAND}^{O_C}(r, \pk) := f(\pk, \op{Sample}(1^n; O_c(r)))
\]</div>
</li>
<li>
<p>当<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(A\)</span><span class="heti-spacing"> </span></span>查询<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(S(\sk, m)\)</span><span class="heti-spacing"> </span></span>时，<span><span class="arithmatex">\(B\)</span><span class="heti-spacing"> </span></span>按如下计算并回复：</p>
<div class="arithmatex">\[
    \op{SIGN}^{O_C}(m, \pk) := \op{Sample}(1^n; O_c(m))
\]</div>
</li>
<li>
<p>当<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(A\)</span><span class="heti-spacing"> </span></span>输出<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\((m, \sigma)\)</span><span class="heti-spacing"> </span></span>时，<span><span class="arithmatex">\(B\)</span><span class="heti-spacing"> </span></span>按如下计算并回复：</p>
<div class="arithmatex">\[
    \op{FINISH}^{O_C}(m, \sigma, \pk) := (\op{Sample}(1^n; O_c(m)), \sigma)
\]</div>
</li>
</ul>
<p>此外，定义<span><span class="heti-spacing"> </span><span class="arithmatex">\(\op{INSTANCE}(pk) = \pk\)</span>.</span> </p>
<p>显然<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\op{INSTANCE}\)</span><span class="heti-spacing"> </span></span>和<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\op{START}\)</span><span class="heti-spacing"> </span></span>满足无历史规约的要求<span><span class="heti-spacing"> </span>.</span> </p>
<div class="admonition success">
<p class="admonition-title">Lemma</p>
<p>设<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(A\)</span><span class="heti-spacing"> </span></span>是一个进行<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(q\)</span><span class="heti-spacing"> </span></span>次量子查询的量子算法<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>进一步，假设从两个分布中抽取<span><span class="heti-spacing"> </span>Oracle <span class="arithmatex">\(O\)</span></span>，第一个分布是一个随机<span class="heti-skip"><span class="heti-spacing"> </span>Oracle<span class="heti-spacing"> </span></span>分布，第二个分布是<span class="heti-skip"><span class="heti-spacing"> </span>Oracle<span class="heti-spacing"> </span></span>在每个输入<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(x\)</span><span class="heti-spacing"> </span></span>处的值独立同分布地由某个分布<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(D\)</span><span class="heti-spacing"> </span></span>所生成而形成的分布，并且<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(D\)</span><span class="heti-spacing"> </span></span>与均匀分布的变差距离不超过<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\varepsilon\)</span>.<span class="heti-spacing"> </span></span>那么，<span><span class="arithmatex">\(A\)</span><span class="heti-spacing"> </span></span>使用两种<span class="heti-skip"><span class="heti-spacing"> </span>Oracle<span class="heti-spacing"> </span></span>的输出分布之间的变差距离不超过<span><span class="heti-spacing"> </span><span class="arithmatex">\(4q^2 \sqrt{\varepsilon}\)</span>.</span></p>
</div>
<p>以上引理表明可以使用一个依据近似于均匀分布的分布<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(D\)</span><span class="heti-spacing"> </span></span>生成的<span class="heti-skip"><span class="heti-spacing"> </span>Oracle <span class="arithmatex">\(O_D\)</span><span class="heti-spacing"> </span></span>替代真正的随机<span><span class="heti-spacing"> </span>Oracle <span class="arithmatex">\(O\)</span></span>，而不会对<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(A\)</span><span class="heti-spacing"> </span></span>的行为产生影响<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>不过，尽管这对<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(A\)</span><span class="heti-spacing"> </span></span>的输出的影响可以忽略，但造成的影响依然比经典情况下的影响要大<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>经典情况的影响为<span><span class="heti-spacing"> </span><span class="arithmatex">\(q \varepsilon\)</span></span>，而量子情况下的影响为<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(4q^2 \sqrt{\varepsilon}\)</span>.<span class="heti-spacing"> </span></span>所以，使用以上引理的量子安全规约往往不像其对应的经典规约的约束那样严格<span><span class="heti-spacing"> </span>.</span></p>
<div class="admonition note">
<p class="admonition-title">Theorem</p>
<p>上述提到的<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\op{FDH-PSF}\)</span><span class="heti-spacing"> </span></span>签名方案上的规约是无历史的<span><span class="heti-spacing"> </span>.</span> </p>
<details class="note" open="open">
<summary>Proof</summary>
<p><span><span class="arithmatex">\(\op{PSF}\)</span><span class="heti-spacing"> </span></span>的定义表明<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(f(\pk, \op{Sample}(1^n))\)</span><span class="heti-spacing"> </span></span>的分布与均匀分布的变差距离小于<span><span class="heti-spacing"> </span><span class="arithmatex">\(\varepsilon_{\op{Sample}}\)</span></span>，其值可忽略<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>因为<span><span class="heti-spacing"> </span><span class="arithmatex">\(O(r) = \op{RAND}^{O_C}(r, \pk) = f(\pk, \op{Sample}(1^n; O_C(r)))\)</span></span>，且<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(O_C\)</span><span class="heti-spacing"> </span></span>是一个真正的随机<span><span class="heti-spacing"> </span>Oracle</span>，所以<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(O(r)\)</span><span class="heti-spacing"> </span></span>的分布独立于其他输入，并且与均匀分布的变差距离不超过<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\varepsilon_{\op{Sample}}\)</span>.<span class="heti-spacing"> </span></span>定义一量子<span><span class="heti-spacing"> </span>Oracle <span class="arithmatex">\(O_{\op{quant}}\)</span></span>，其将<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\ket{x, y}\)</span><span class="heti-spacing"> </span></span>映射到<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\ket{x, y \oplus O(x)}\)</span>.<span class="heti-spacing"> </span></span>根据上述引理，对于任意进行<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(q\)</span><span class="heti-spacing"> </span></span>次随机<span class="heti-skip"><span class="heti-spacing"> </span>Oracle<span class="heti-spacing"> </span></span>查询的算法<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(B\)</span><span class="heti-spacing"> </span></span>而言，其使用真正的随机<span class="heti-skip"><span class="heti-spacing"> </span>Oracle<span class="heti-spacing"> </span></span>所产生的输出的分布与其使用“不那么”随机的<span class="heti-skip"><span class="heti-spacing"> </span>Oracle <span class="arithmatex">\(O_{\op{quant}}\)</span><span class="heti-spacing"> </span></span>所产生的输出的分布之间的变差距离不超过<span><span class="heti-spacing"> </span><span class="arithmatex">\(4q^2 \sqrt{\varepsilon_{\op{Sample}}}\)</span></span>，依然是可忽略的<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>因此，<span><span class="arithmatex">\(O_{\op{quant}}\)</span><span class="heti-spacing"> </span></span>与随机<span class="heti-skip"><span class="heti-spacing"> </span>Oracle<span class="heti-spacing"> </span></span>是计算上不可区分的<span><span class="heti-spacing"> </span>.</span></p>
<p><a href="https://eprint.iacr.org/2007/432.pdf"><span>[GPV08]<span class="heti-spacing"> </span></span></a>还表明，对于所有查询，<span><span class="arithmatex">\(\op{SIGN}^{O_C}(m, \pk)\)</span><span class="heti-spacing"> </span></span>与<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\op{RAND}^{O_C}(\cdot, \pk)\)</span><span class="heti-spacing"> </span></span>是相一致的，并且如果<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(A\)</span><span class="heti-spacing"> </span></span>输出一个有效的伪造签名<span><span class="heti-spacing"> </span><span class="arithmatex">\((m, \sigma)\)</span></span>，那么<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\op{FINISH}^{O_C}(m, \sigma, \pk)\)</span><span class="heti-spacing"> </span></span>产生<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\mathcal{F}\)</span><span class="heti-spacing"> </span></span>的一个碰撞的概率为<span><span class="heti-spacing"> </span><span class="arithmatex">\(1 - 2^{-E}\)</span></span>，其中<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(E\)</span><span class="heti-spacing"> </span></span>为给定<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(f(\pk, \sigma) = y\)</span><span class="heti-spacing"> </span></span>时，分布在<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\sigma\)</span><span class="heti-spacing"> </span></span>上的最小熵在<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(f(\pk, \cdot)\)</span><span class="heti-spacing"> </span></span>的值域内的所有<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(y\)</span><span class="heti-spacing"> </span></span>上的最小值<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>因为<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\op{PSF}\)</span><span class="heti-spacing"> </span></span>具备的是超对数最小熵，所以<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(1 - 2^{-E}\)</span><span class="heti-spacing"> </span></span>与<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(1\)</span><span class="heti-spacing"> </span></span>之间的差距是可忽略的<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>不过，任何一个非零常数最小熵都足以使得这个数字是一个不可忽略的<span class="heti-skip"><span class="heti-spacing"> </span>1<span class="heti-spacing"> </span></span>的分数<span><span class="heti-spacing"> </span>.</span> </p>
</details>
</div>
<p>从以上的两个定理可以得到这部分的主要结论：</p>
<div class="admonition success">
<p class="admonition-title">Corollary</p>
<p>如果量子可访问伪随机函数是存在的，并且<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\mathcal{F}\)</span><span class="heti-spacing"> </span></span>是一个能够安全抵抗量子敌手的<span><span class="heti-spacing"> </span><span class="arithmatex">\(\op{PSF}\)</span></span>，那么<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\op{FDH-PSF}\)</span><span class="heti-spacing"> </span></span>签名方案在量子可访问随机<span class="heti-skip"><span class="heti-spacing"> </span>Oracle<span class="heti-spacing"> </span></span>模型下是安全的<span><span class="heti-spacing"> </span>.</span></p>
</div>
<h3 id="secure-signatures-from-claw-free-permutations">Secure Signatures from Claw-Free Permutations<a class="headerlink" href="#secure-signatures-from-claw-free-permutations" title="Permanent link">¶</a></h3>
<p>这部分将会给出如何使用无爪置换构建三个具有无历史规约进而在量子可访问随机<span class="heti-skip"><span class="heti-spacing"> </span>Oracle<span class="heti-spacing"> </span></span>模型下是安全的签名方案<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>首先是标准的<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\op{FDH}\)</span><span class="heti-spacing"> </span></span>签名方案，使用无爪置换；然后是 <em>Katz and Wang</em><a href="https://dl.acm.org/doi/10.1145/948109.948132"><span>[KW03]<span class="heti-spacing"> </span></span></a>的签名方案；最后是通过无爪置换诱导得到一个<span><span class="heti-spacing"> </span><span class="arithmatex">\(\op{PSF}\)</span></span>，最后用于构建<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\op{FDH-PSF}\)</span><span class="heti-spacing"> </span></span>签名方案<span><span class="heti-spacing"> </span>.</span></p>
<p>回顾无爪置换的定义，其是一对陷门置换<span><span class="heti-spacing"> </span><span class="arithmatex">\((\mathcal{F}_1, \mathcal{F}_2)\)</span></span>，其中<span><span class="heti-spacing"> </span><span class="arithmatex">\(\mathcal{F}_i = (G_i, f_i, f_i^{-1})\)</span></span>，满足以下性质：</p>
<ul>
<li>
<p><span class="arithmatex">\(G_1 = G_2 = G\)</span></p>
</li>
<li>
<p>对任意公钥<span><span class="heti-spacing"> </span><span class="arithmatex">\(\pk\)</span></span>，<span><span class="arithmatex">\(f_1(\pk, \cdot)\)</span><span class="heti-spacing"> </span></span>和<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(f_2(\pk, \cdot)\)</span><span class="heti-spacing"> </span></span>的定义域和值域是相同的</p>
</li>
<li>
<p>只给出公钥<span><span class="heti-spacing"> </span><span class="arithmatex">\(\pk\)</span></span>，任何<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\op{PPT}\)</span><span class="heti-spacing"> </span></span>敌手能够找出一组<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\((x_1, x_2)\)</span><span class="heti-spacing"> </span></span>使得<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(f_1(\pk, x_1) = f_2(\pk, x_2)\)</span><span class="heti-spacing"> </span></span>的概率是可忽略的，这样的一个组叫做一个爪</p>
</li>
</ul>
<p>无爪置换实际上是具有随机自规约的陷门置换的推广<span><span class="heti-spacing"> </span>.</span> <strong>随机自规约（random self-reduction）</strong> 是指一种将问题的最坏情况的实例<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(x\)</span><span class="heti-spacing"> </span></span>转化为同一问题的某个随机实例<span><span class="heti-spacing"> </span><span class="arithmatex">\(y\)</span></span>，使得<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(y\)</span><span class="heti-spacing"> </span></span>的解决方法可以帮助解决<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(x\)</span><span class="heti-spacing"> </span></span>的方法<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span><a href="https://eprint.iacr.org/2002/103.pdf"><span class="heti-skip"><span class="heti-spacing"> </span>[DR03]<span class="heti-spacing"> </span></span></a>表明任意带有随机自规约的陷门置换（如<span><span class="heti-spacing"> </span>RSA</span>）都可以用于构建一个无爪置换<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>目前还没有无爪置换可以抵御量子攻击<span><span class="heti-spacing"> </span>.</span></p>
<ul>
<li>
<p><strong>无爪置换构建的全域哈希签名（FDH Signatures from Claw-Free Permutations）</strong>：这里的构建只使用了<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\mathcal{F}_1\)</span><span class="heti-spacing"> </span></span>进行实例化，如下：</p>
<ul>
<li>
<p><span><span class="arithmatex">\(G\)</span><span class="heti-spacing"> </span></span>是无爪置换的生成算法</p>
</li>
<li>
<p><span class="arithmatex">\(S^O(\sk, m) = f_1^{-1}(\sk, O(m))\)</span></p>
</li>
<li>
<p><span><span class="arithmatex">\(V^O(\pk, m, \sigma) = 1\)</span><span class="heti-spacing"> </span></span>当且仅当<span><span class="heti-spacing"> </span><span class="arithmatex">\(O(m) = f_1(\pk, \sigma)\)</span></span></p>
</li>
</ul>
<p>下面给出一个无历史规约<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>这一规约的随机<span class="heti-skip"><span class="heti-spacing"> </span>Oracle <span class="arithmatex">\(O_C(r)\)</span><span class="heti-spacing"> </span></span>会返回一个随机对<span><span class="heti-spacing"> </span><span class="arithmatex">\((a, b)\)</span></span>，其中<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(a\)</span><span class="heti-spacing"> </span></span>是一个从<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\mathcal{F}_1\)</span><span class="heti-spacing"> </span></span>和<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\mathcal{F}_2\)</span><span class="heti-spacing"> </span></span>的定义域中随机采样得到的，而<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(b\)</span><span class="heti-spacing"> </span></span>是从<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\{1, 2, \ldots, p\}\)</span><span class="heti-spacing"> </span></span>中随机采样得到的，其中<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(p\)</span><span class="heti-spacing"> </span></span>会在之后选取<span><span class="heti-spacing"> </span>.</span></p>
<p>接下来从<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\mathcal{S}\)</span><span class="heti-spacing"> </span></span>的经典敌手<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(A\)</span><span class="heti-spacing"> </span></span>去构建一个<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\((\mathcal{F}_1, \mathcal{F}_2)\)</span><span class="heti-spacing"> </span></span>的经典敌手<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(B\)</span>. <span class="arithmatex">\(B\)</span><span class="heti-spacing"> </span></span>接受输入<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\pk\)</span><span class="heti-spacing"> </span></span>后，按如下工作：</p>
<ul>
<li>
<p>计算<span><span class="heti-spacing"> </span><span class="arithmatex">\(\op{START}(\pk) = (\pk, \pk)\)</span></span>，以<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\pk\)</span><span class="heti-spacing"> </span></span>为输入模拟<span><span class="heti-spacing"> </span><span class="arithmatex">\(A\)</span></span></p>
</li>
<li>
<p>当<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(A\)</span><span class="heti-spacing"> </span></span>查询<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(O(r)\)</span><span class="heti-spacing"> </span></span>时，计算<span><span class="heti-spacing"> </span><span class="arithmatex">\(\op{RAND}^{O_C}(r, \pk)\)</span></span>，对于每个字符串<span><span class="heti-spacing"> </span><span class="arithmatex">\(r\)</span></span>，<span><span class="arithmatex">\(\op{RAND}\)</span><span class="heti-spacing"> </span></span>按如下工作：计算<span><span class="heti-spacing"> </span><span class="arithmatex">\((a, b) \from O_C(r)\)</span></span>，如果<span><span class="heti-spacing"> </span><span class="arithmatex">\(b = 1\)</span></span>，则返回<span><span class="heti-spacing"> </span><span class="arithmatex">\(f_2(\pk, a)\)</span></span>，否则返回<span><span class="heti-spacing"> </span><span class="arithmatex">\(f_1(\pk, a)\)</span></span></p>
</li>
<li>
<p>当<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(A\)</span><span class="heti-spacing"> </span></span>查询<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(S(\sk, m)\)</span><span class="heti-spacing"> </span></span>时，计算<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\op{SIGN}^{O_C}(m, \pk)\)</span>. <span class="arithmatex">\(\op{SIGN}\)</span><span class="heti-spacing"> </span></span>按如下工作：计算<span><span class="heti-spacing"> </span><span class="arithmatex">\((a, b) \from O_C(m)\)</span></span>，如果<span><span class="heti-spacing"> </span><span class="arithmatex">\(b \neq 1\)</span></span>，则返回<span><span class="heti-spacing"> </span><span class="arithmatex">\(a\)</span></span>，否则失败</p>
</li>
<li>
<p>当<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(A\)</span><span class="heti-spacing"> </span></span>输出<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\((m, \sigma)\)</span><span class="heti-spacing"> </span></span>时，计算<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\op{FINISH}^{O_C}(m, \sigma, \pk)\)</span>. <span class="arithmatex">\(\op{FINISH}\)</span><span class="heti-spacing"> </span></span>按如下工作：计算<span><span class="heti-spacing"> </span><span class="arithmatex">\((a, b) \from O_C(m)\)</span></span>，输出<span><span class="heti-spacing"> </span><span class="arithmatex">\((\sigma, a)\)</span></span></p>
</li>
</ul>
<p>此外，<span class="arithmatex">\(\op{INSTANCE}(\pk) = \pk\)</span>，与之前的方案类似，所以<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\op{INSTANCE}\)</span><span class="heti-spacing"> </span></span>和<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\op{START}\)</span><span class="heti-spacing"> </span></span>满足无历史规约的要求<span><span class="heti-spacing"> </span>.</span></p>
<div class="admonition note">
<p class="admonition-title">Theorem</p>
<p>上述的规约是无历史的<span><span class="heti-spacing"> </span>.</span></p>
<details class="note" open="open">
<summary>Proof</summary>
<p><span><span class="arithmatex">\(\op{RAND}^{O_C}(r, \pk)\)</span><span class="heti-spacing"> </span></span>是完全随机且独立分布的，因为<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(f_1(\pk, a)\)</span><span class="heti-spacing"> </span></span>和<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(f_2(\pk, a)\)</span><span class="heti-spacing"> </span></span>都是随机的（<span><span class="arithmatex">\(f_b(\pk, \cdot)\)</span><span class="heti-spacing"> </span></span>是置换而<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(a\)</span><span class="heti-spacing"> </span></span>是随机的）<span>.<span class="heti-spacing"> </span></span>只要<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(O_C(m)\)</span><span class="heti-spacing"> </span></span>计算得到的<span><span class="heti-spacing"> </span><span class="arithmatex">\(b \neq 1\)</span></span>，<span><span class="arithmatex">\(\op{SIGN}^{O_C}(m, \pk)\)</span><span class="heti-spacing"> </span></span>的行为就与<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\op{RAND}^{O_C}(\cdot, \pk)\)</span><span class="heti-spacing"> </span></span>是一致的<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>因为如果<span><span class="heti-spacing"> </span><span class="arithmatex">\(\op{RAND}^{O_C}(m, \pk) = f_1(\pk, \op{SIGN}^{O_C}(m, \pk))\)</span></span>，那么<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(V^{\op{RAND}^{O_C}(\cdot, \pk)}(\pk, m, \op{SIGN}^{O_C}(m, \pk))\)</span><span class="heti-spacing"> </span></span>会输出<span class="heti-skip"><span class="heti-spacing"> </span>1.<span class="heti-spacing"> </span></span>而因为<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(b \neq 1\)</span><span class="heti-spacing"> </span></span>有<span><span class="heti-spacing"> </span><span class="arithmatex">\(\op{RAND}^{O_C}(m, \pk) = f_1(\pk, a)\)</span></span>，且<span><span class="heti-spacing"> </span><span class="arithmatex">\(\op{SIGN}^{O_C}(m, \pk) = a\)</span></span>，所以等式成立<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>所有签名查询均不失败的概率为<span><span class="heti-spacing"> </span><span class="arithmatex">\((1 - 1/p)^{q_{\op{SIGN}}}\)</span></span>，如果选定<span><span class="heti-spacing"> </span><span class="arithmatex">\(p = q_{\op{SIGN}}\)</span></span>，那么该值为<span><span class="heti-spacing"> </span><span class="arithmatex">\(e^{-1} - O(1)\)</span></span>，是不可忽略的<span><span class="heti-spacing"> </span>.</span> </p>
<p>假设<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(A\)</span><span class="heti-spacing"> </span></span>返回了一个有效的伪造签名<span><span class="heti-spacing"> </span><span class="arithmatex">\((m, \sigma)\)</span></span>，这意味着<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(A\)</span><span class="heti-spacing"> </span></span>从未查询过对<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(m\)</span><span class="heti-spacing"> </span></span>的签名，并且<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(f_1(\pk, \sigma) = \op{RAND}^{O_C}(m, \pk)\)</span>.<span class="heti-spacing"> </span></span>如果<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(O_C(m)\)</span><span class="heti-spacing"> </span></span>计算得到的<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(b = 1\)</span><span class="heti-spacing"> </span></span>的话，那么就有<span><span class="heti-spacing"> </span><span class="arithmatex">\(f_1(\pk, \sigma) = \op{RAND}^{O_C}(m, \pk) = f_2(\pk, a)\)</span></span>，这意味着<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\((\sigma, a)\)</span><span class="heti-spacing"> </span></span>是一个爪<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>因为<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(A\)</span><span class="heti-spacing"> </span></span>从未查询过对<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(m\)</span><span class="heti-spacing"> </span></span>的签名，所以其不可能区分出<span><span class="heti-spacing"> </span><span class="arithmatex">\(a\)</span></span>，也就是说，<span><span class="arithmatex">\(b = 1\)</span><span class="heti-spacing"> </span></span>使得<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(a\)</span><span class="heti-spacing"> </span></span>是<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(O(m)\)</span><span class="heti-spacing"> </span></span>在<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(f_2\)</span><span class="heti-spacing"> </span></span>下的原像，以及<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(b \neq 1\)</span><span class="heti-spacing"> </span></span>使得<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(a\)</span><span class="heti-spacing"> </span></span>是<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(O(m)\)</span><span class="heti-spacing"> </span></span>在<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(f_1\)</span><span class="heti-spacing"> </span></span>下的原像的这两种情况是不可区分的<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>而<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(b = 1\)</span><span class="heti-spacing"> </span></span>的概率是<span><span class="heti-spacing"> </span><span class="arithmatex">\(1/p\)</span></span>，所以<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(B\)</span><span class="heti-spacing"> </span></span>将一个有效的签名以不可忽略的概率转化为一个爪<span><span class="heti-spacing"> </span>.</span></p>
</details>
</div>
<div class="admonition success">
<p class="admonition-title">Corollary</p>
<p>如果量子可访问伪随机函数是存在的，并且<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\((\mathcal{F}_1, \mathcal{F}_2)\)</span><span class="heti-spacing"> </span></span>是一对无爪陷门置换，那么用<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\mathcal{F}_1\)</span><span class="heti-spacing"> </span></span>构建的<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\op{FDH}\)</span><span class="heti-spacing"> </span></span>签名方案可以抵御量子敌手<span><span class="heti-spacing"> </span>.</span></p>
</div>
<p>因为在上述规约中模拟运行的<span class="heti-skip"><span class="heti-spacing"> </span>Oracle<span class="heti-spacing"> </span></span>是真随机的，也就没有用到之前的引理，所以该约束的紧度与经典情况下的是相同的<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>也就是说，如果<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(A\)</span><span class="heti-spacing"> </span></span>在进行<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(q_{\op{SIGN}}\)</span><span class="heti-spacing"> </span></span>次签名查询时有<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\varepsilon\)</span><span class="heti-spacing"> </span></span>的优势，那么<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(B\)</span><span class="heti-spacing"> </span></span>有大约<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\varepsilon/q_{\op{SIGN}}\)</span><span class="heti-spacing"> </span></span>的优势<span><span class="heti-spacing"> </span>.</span> </p>
</li>
<li>
<p><strong><span>Katz-Wang<span class="heti-spacing"> </span></span>签名方案（Katz-Wang Signature Scheme）</strong>：其是<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\op{FDH}\)</span><span class="heti-spacing"> </span></span>的一种变体，这一方案容许一个近似经典情况下的非常紧的规约，即如果有敌手的优势为<span><span class="heti-spacing"> </span><span class="arithmatex">\(\varepsilon\)</span></span>，那么该规约可以以<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\varepsilon/2\)</span><span class="heti-spacing"> </span></span>的优势找到一个爪<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>给定一对陷门置换<span><span class="heti-spacing"> </span><span class="arithmatex">\((\mathcal{F}_1, \mathcal{F}_2)\)</span></span>，按如下方法构建：</p>
<ul>
<li>
<p><span><span class="arithmatex">\(G\)</span><span class="heti-spacing"> </span></span>是<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\mathcal{F}\)</span><span class="heti-spacing"> </span></span>的密钥生成算法</p>
</li>
<li>
<p><span class="arithmatex">\(S^O(\sk, m) = f_1^{-1}(\sk, O(b, m))\)</span>，其中<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(b\)</span><span class="heti-spacing"> </span></span>是一个随机比特</p>
</li>
<li>
<p><span><span class="arithmatex">\(V^O(\pk, m, \sigma) = 1\)</span><span class="heti-spacing"> </span></span>当且仅当<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(O(0, m) = f_1(\pk, \sigma)\)</span><span class="heti-spacing"> </span></span>或<span><span class="heti-spacing"> </span><span class="arithmatex">\(O(1, m) = f_1(\pk, \sigma)\)</span></span></p>
</li>
</ul>
<p>进而从<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\mathcal{S}\)</span><span class="heti-spacing"> </span></span>的敌手<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(A\)</span><span class="heti-spacing"> </span></span>构建一个<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\((\mathcal{F}_1, \mathcal{F}_2)\)</span><span class="heti-spacing"> </span></span>的敌手<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(B\)</span>.<span class="heti-spacing"> </span></span>这一规约的随机<span class="heti-skip"><span class="heti-spacing"> </span>Oracle <span class="arithmatex">\(O_C(r)\)</span><span class="heti-spacing"> </span></span>会生成一个随机对<span><span class="heti-spacing"> </span><span class="arithmatex">\((a, b)\)</span></span>，其中<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(a\)</span><span class="heti-spacing"> </span></span>是<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\mathcal{F}_1\)</span><span class="heti-spacing"> </span></span>和<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\mathcal{F}_2\)</span><span class="heti-spacing"> </span></span>定义域中的一个随机元素，而<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(b\)</span><span class="heti-spacing"> </span></span>是一个随机比特<span class="heti-skip"><span class="heti-spacing"> </span>. <span class="arithmatex">\(B\)</span><span class="heti-spacing"> </span></span>接受输入<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\pk\)</span><span class="heti-spacing"> </span></span>后，按如下工作：</p>
<ul>
<li>
<p>计算<span><span class="heti-spacing"> </span><span class="arithmatex">\(\op{START}(\pk) = (\pk, \pk)\)</span></span>，以<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\pk\)</span><span class="heti-spacing"> </span></span>为输入模拟<span><span class="heti-spacing"> </span><span class="arithmatex">\(A\)</span></span></p>
</li>
<li>
<p>当<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(A\)</span><span class="heti-spacing"> </span></span>查询<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(O(b, r)\)</span><span class="heti-spacing"> </span></span>时，计算<span><span class="heti-spacing"> </span><span class="arithmatex">\(\op{RAND}^{O_C}(b, r, \pk)\)</span></span>，对于每个字符串<span><span class="heti-spacing"> </span><span class="arithmatex">\((b, r)\)</span></span>，<span><span class="arithmatex">\(\op{RAND}\)</span><span class="heti-spacing"> </span></span>按如下工作：计算<span><span class="heti-spacing"> </span><span class="arithmatex">\((a, b') \from O_C(r)\)</span></span>，如果<span><span class="heti-spacing"> </span><span class="arithmatex">\(b = b'\)</span></span>，则返回<span><span class="heti-spacing"> </span><span class="arithmatex">\(f_1(\pk, a)\)</span></span>，否则返回<span><span class="heti-spacing"> </span><span class="arithmatex">\(f_2(\pk, a)\)</span></span></p>
</li>
<li>
<p>当<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(A\)</span><span class="heti-spacing"> </span></span>查询<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(S(\sk, m)\)</span><span class="heti-spacing"> </span></span>时，计算<span><span class="heti-spacing"> </span><span class="arithmatex">\(\op{SIGN}^{O_C}(m, \pk)\)</span></span>，<span><span class="arithmatex">\(\op{SIGN}\)</span><span class="heti-spacing"> </span></span>按如下工作：计算<span><span class="heti-spacing"> </span><span class="arithmatex">\((a, b) \from O_C(m)\)</span></span>，返回<span><span class="heti-spacing"> </span><span class="arithmatex">\(a\)</span></span></p>
</li>
<li>
<p>当<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(A\)</span><span class="heti-spacing"> </span></span>输出<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\((m, \sigma)\)</span><span class="heti-spacing"> </span></span>时，计算<span><span class="heti-spacing"> </span><span class="arithmatex">\(\op{FINISH}^{O_C}(m, \sigma, \pk)\)</span></span>，<span><span class="arithmatex">\(\op{FINISH}\)</span><span class="heti-spacing"> </span></span>按如下工作：计算<span><span class="heti-spacing"> </span><span class="arithmatex">\((a, b) \from O_C(m)\)</span></span>，如果<span><span class="heti-spacing"> </span><span class="arithmatex">\(a = \sigma\)</span></span>，则中止，否则输出<span><span class="heti-spacing"> </span><span class="arithmatex">\((\sigma, a)\)</span></span></p>
</li>
</ul>
<p><span><span class="arithmatex">\(\op{INSTANCE}\)</span><span class="heti-spacing"> </span></span>和<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\op{START}\)</span><span class="heti-spacing"> </span></span>不再赘述，其满足无历史规约的要求<span><span class="heti-spacing"> </span>.</span></p>
<div class="admonition note">
<p class="admonition-title">Theorem</p>
<p>上述的规约是无历史的<span><span class="heti-spacing"> </span>.</span></p>
<details class="note" open="open">
<summary>Proof</summary>
<p><span><span class="arithmatex">\(\op{RAND}^{O_C}(b, r, \pk)\)</span><span class="heti-spacing"> </span></span>是完全随机且独立分布的，同之前一致<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>观察到<span><span class="heti-spacing"> </span><span class="arithmatex">\(f_1(\pk, \op{SIGN}^{O_C}(m, \pk)) = f_1(\pk, a) = O(b, m)\)</span></span>，其中<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\((a, b) \from O_C(m)\)</span>.<span class="heti-spacing"> </span></span>所以，签名查询总是会以合法的签名进行回复，并且因为<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(b\)</span><span class="heti-spacing"> </span></span>是均匀选选取的，整个签名的分布与正确的签名算法是相同的<span><span class="heti-spacing"> </span>.</span></p>
<p>假设<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(A\)</span><span class="heti-spacing"> </span></span>返回了一个有效的伪造签名<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>令<span><span class="heti-spacing"> </span><span class="arithmatex">\((a, b) \from O_C(m)\)</span></span>，共会有两种情况，分别对应<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\sigma\)</span><span class="heti-spacing"> </span></span>对应的签名使用的是<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(b\)</span><span class="heti-spacing"> </span></span>还是<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(1 - b\)</span>.<span class="heti-spacing"> </span></span>第一种情况下，就会有<span><span class="heti-spacing"> </span><span class="arithmatex">\(f_1(\pk, \sigma) = O(b, m) = f_1(\pk, a)\)</span></span>，也就有<span><span class="heti-spacing"> </span><span class="arithmatex">\(\sigma = a\)</span></span>，这种情况下会中止<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>第二种情况下，就会有<span><span class="heti-spacing"> </span><span class="arithmatex">\(f_1(\pk, \sigma) = O(1 - b, m) = f_2(\pk, a)\)</span></span>，这种情况下<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\((\sigma, a)\)</span><span class="heti-spacing"> </span></span>是一个爪<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>而因为敌手从未查询过对<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(m\)</span><span class="heti-spacing"> </span></span>的签名，所以其不可能区分出两种情况<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>也就是说，失败的概率至多为<span><span class="heti-spacing"> </span><span class="arithmatex">\(1/2\)</span></span>，所以成功的概率是不可忽略的<span><span class="heti-spacing"> </span>.</span></p>
</details>
</div>
<div class="admonition success">
<p class="admonition-title">Corollary</p>
<p>如果量子可访问伪随机函数是存在的，并且<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\((\mathcal{F}_1, \mathcal{F}_2)\)</span><span class="heti-spacing"> </span></span>是一对无爪陷门置换，那么用<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\mathcal{F}_1\)</span><span class="heti-spacing"> </span></span>构建的<span class="heti-skip"><span class="heti-spacing"> </span>Katz-Wang<span class="heti-spacing"> </span></span>签名方案可以抵御量子敌手<span><span class="heti-spacing"> </span>.</span></p>
</div>
</li>
<li>
<p><strong>无爪置换诱导的<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\op{PSF}\)</span><span class="heti-spacing"> </span></span>签名（PSF Signatures from Claw-Free Permutations）</strong>：给定一组无爪置换<span><span class="heti-spacing"> </span><span class="arithmatex">\((\mathcal{F}_1, \mathcal{F}_2)\)</span></span>，按如下定义<span><span class="heti-spacing"> </span><span class="arithmatex">\(\op{PSF}\)</span></span>：</p>
<ul>
<li>
<p><span><span class="arithmatex">\(G\)</span><span class="heti-spacing"> </span></span>是置换的生成算法</p>
</li>
<li>
<p><span><span class="arithmatex">\(\op{Sample}(\pk)\)</span><span class="heti-spacing"> </span></span>生成一个随机比特<span><span class="heti-spacing"> </span><span class="arithmatex">\(b\)</span></span>，以及<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(f_b\)</span><span class="heti-spacing"> </span></span>的定义域内的一个随机元素<span><span class="heti-spacing"> </span><span class="arithmatex">\(x\)</span></span>，返回<span><span class="heti-spacing"> </span><span class="arithmatex">\((x, b)\)</span></span></p>
</li>
<li>
<p><span class="arithmatex">\(f(\pk, x, b) = f_b(\pk, x)\)</span>，以及<span><span class="heti-spacing"> </span><span class="arithmatex">\(f^{-1}(\sk, y) = (f_b^{-1}(\sk, y), b)\)</span></span>，其中<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(b\)</span><span class="heti-spacing"> </span></span>是随机比特</p>
</li>
</ul>
<p>如果这一<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\op{PSF}\)</span><span class="heti-spacing"> </span></span>已经有一对碰撞<span><span class="heti-spacing"> </span><span class="arithmatex">\(((x_1, b_1), (x_2, b_2))\)</span></span>，那么就有</p>
<div class="arithmatex">\[
    f_{b_1}(\pk, x_1) = f(\pk, x_1, b_1) = f(\pk, x_2, b_2) = f_{b_2}(\pk, x_2).
\]</div>
<p>如果<span><span class="heti-spacing"> </span><span class="arithmatex">\(b_ = b_2\)</span></span>，因为<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(f_{b_1}\)</span><span class="heti-spacing"> </span></span>是一个置换，所以必然有<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(x_1 = x_2\)</span>.<span class="heti-spacing"> </span></span>但因为这是一对碰撞，必然有<span><span class="heti-spacing"> </span><span class="arithmatex">\((x_1, b_1) \neq (x_2, b_2)\)</span></span>，所以<span><span class="heti-spacing"> </span><span class="arithmatex">\(b_1 \neq b_2\)</span></span>，也就是说，<span><span class="arithmatex">\((x_1, x_2)\)</span><span class="heti-spacing"> </span></span>或<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\((x_2, x_1)\)</span><span class="heti-spacing"> </span></span>是一个爪<span><span class="heti-spacing"> </span>.</span></p>
<p>因此，可以用以上<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\op{PSF}\)</span><span class="heti-spacing"> </span></span>实例化一个<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\op{FDH}\)</span><span class="heti-spacing"> </span></span>签名方案<span><span class="heti-spacing"> </span>.</span></p>
<ul>
<li>
<p><span><span class="arithmatex">\(G\)</span><span class="heti-spacing"> </span></span>是置换的生成算法</p>
</li>
<li>
<p><span class="arithmatex">\(S^O(\sk, m) = (f_b^{-1}(\sk, O(m)), b)\)</span>，其中<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(b\)</span><span class="heti-spacing"> </span></span>是一个随机比特</p>
</li>
<li>
<p><span><span class="arithmatex">\(V^O(\pk, m, (\sigma, b)) = 1\)</span><span class="heti-spacing"> </span></span>当且仅当<span><span class="heti-spacing"> </span><span class="arithmatex">\(O(m) = f_b(\pk, \sigma)\)</span></span></p>
</li>
</ul>
<p>这一方案的安全性来自于<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\op{FDH-PSF}\)</span><span class="heti-spacing"> </span></span>签名方案的安全性<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>不过这一<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\op{PSF}\)</span><span class="heti-spacing"> </span></span>的最小熵只有<span><span class="heti-spacing"> </span>1</span>，会在约束的紧度上有所损失<span><span class="heti-spacing"> </span>.</span></p>
</li>
</ul>
<h2 id="encryption-schemes-in-the-quantum-accessible-random-oracle-model">Encryption Schemes in the Quantum-Accessible Random Oracle Model<a class="headerlink" href="#encryption-schemes-in-the-quantum-accessible-random-oracle-model" title="Permanent link">¶</a></h2>
<p>这一部分将证明两种加密方案的安全性，第一种是由<span class="heti-skip"><span class="heti-spacing"> </span>Bellare<span class="heti-spacing"> </span></span>和<span class="heti-skip"><span class="heti-spacing"> </span>Rogaway<span class="heti-spacing"> </span></span>提出的<span class="heti-skip"><span class="heti-spacing"> </span>BR<span class="heti-spacing"> </span></span>加密方案，将会证明其为<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\op{CPA}\)</span><span class="heti-spacing"> </span></span>安全的<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>第二种是由<span class="heti-skip"><span class="heti-spacing"> </span>BR<span class="heti-spacing"> </span></span>加密方案的混合泛化版本，将会证明其为<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\op{CCA}\)</span><span class="heti-spacing"> </span></span>安全的<span><span class="heti-spacing"> </span>.</span></p>
<p>理想情况上，也可以像证明签名方案的安全性那样定义一个普遍的规约，然后证明这样的规约表明了量子可访问随机<span class="heti-skip"><span class="heti-spacing"> </span>Oracle<span class="heti-spacing"> </span></span>模型下的安全性<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>不幸的是，对于加密方案定义无历史规约是比签名方案更加困难的<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>因此，接下来会直接在量子可访问随机<span class="heti-skip"><span class="heti-spacing"> </span>Oracle<span class="heti-spacing"> </span></span>模型下证明这两种加密方案的安全性<span><span class="heti-spacing"> </span>.</span></p>
<h3 id="cpa-security-of-br-encryption">CPA Security of BR Encryption<a class="headerlink" href="#cpa-security-of-br-encryption" title="Permanent link">¶</a></h3>
<div class="admonition info">
<p class="admonition-title">Definition</p>
<p><strong>(BR Encryption Scheme)</strong> 设<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\mathcal{F} = (G_0, f, f^{-1})\)</span><span class="heti-spacing"> </span></span>是一个单射陷门函数，<span><span class="arithmatex">\(O\)</span><span class="heti-spacing"> </span></span>是一个值域与<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(f(\pk, \cdot)\)</span><span class="heti-spacing"> </span></span>相同的哈希函数<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>定义如下的加密方案<span><span class="heti-spacing"> </span><span class="arithmatex">\(\mathcal{E} = (G, E, D)\)</span></span>：</p>
<ul>
<li>
<p><span class="arithmatex">\(G = G_0\)</span></p>
</li>
<li>
<p><span class="arithmatex">\(E^O(\pk, m) = (f(\pk, r), O(r) \oplus m)\)</span>，其中<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(r\)</span><span class="heti-spacing"> </span></span>是一个随机串</p>
</li>
<li>
<p><span class="arithmatex">\(D^O(\sk, c) = c \oplus f^{-1}(\sk, y)\)</span></p>
</li>
</ul>
<p>其中用到的量子免疫单射陷门函数可以从格中困难问题构建<span><span class="heti-spacing"> </span>.</span></p>
</div>
<div class="admonition note">
<p class="admonition-title">Theorem</p>
<p>如果量子可访问伪随机函数是存在的，并且<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\mathcal{F}\)</span><span class="heti-spacing"> </span></span>是一个量子免疫单射陷门函数，那么<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\mathcal{E}\)</span><span class="heti-spacing"> </span></span>是量子<span class="heti-skip"><span class="heti-spacing"> </span>CPA<span class="heti-spacing"> </span></span>安全的<span><span class="heti-spacing"> </span>.</span></p>
</div>
<p>此处证明省略，因为<span class="heti-skip"><span class="heti-spacing"> </span>BR<span class="heti-spacing"> </span></span>加密方案的<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\op{CPA}\)</span><span class="heti-spacing"> </span></span>安全性是混合加密方案的<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\op{CCA}\)</span><span class="heti-spacing"> </span></span>安全性的一个特殊情况<span><span class="heti-spacing"> </span>.</span></p>
<h3 id="cca-security-of-hybrid-encryption">CCA Security of Hybrid Encryption<a class="headerlink" href="#cca-security-of-hybrid-encryption" title="Permanent link">¶</a></h3>
<p>接下来证明下述标准混合加密的<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\op{CCA}\)</span><span class="heti-spacing"> </span></span>安全性，其是<span class="heti-skip"><span class="heti-spacing"> </span>BR<span class="heti-spacing"> </span></span>加密方案的一个泛化版本，可以用一个单射陷门函数和对称加密方案构建<span><span class="heti-spacing"> </span>.</span></p>
<div class="admonition info">
<p class="admonition-title">Definition</p>
<p><strong>(Hybrid Encryption Scheme)</strong> 设<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\mathcal{F} = (G_0, f, f^{-1})\)</span><span class="heti-spacing"> </span></span>是一个单射陷门函数，<span><span class="arithmatex">\(\mathcal{E_S} = (E_S, D_S)\)</span><span class="heti-spacing"> </span></span>是一个<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\op{CCA}\)</span><span class="heti-spacing"> </span></span>安全的对称加密方案，<span><span class="arithmatex">\(O\)</span><span class="heti-spacing"> </span></span>是一个哈希函数<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>定义如下的混合加密方案<span><span class="heti-spacing"> </span><span class="arithmatex">\(\mathcal{E} = (G, E, D)\)</span></span>：</p>
<ul>
<li>
<p><span class="arithmatex">\(G = G_0\)</span></p>
</li>
<li>
<p><span class="arithmatex">\(E^O(\pk, m) = (f(\pk, r), E_S(O(r), m))\)</span>，其中<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(r\)</span><span class="heti-spacing"> </span></span>是一个随机串</p>
</li>
<li>
<p><span class="arithmatex">\(D^O(\sk, (y, c)) = D_S(O(r'), c)\)</span>，其中<span><span class="heti-spacing"> </span><span class="arithmatex">\(r' = f^{-1}(\sk, y)\)</span></span></p>
</li>
</ul>
</div>
<p>可以发现<span class="heti-skip"><span class="heti-spacing"> </span>BR<span class="heti-spacing"> </span></span>加密方案实际上是<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\mathcal{E_S}\)</span><span class="heti-spacing"> </span></span>为一次一密的混合加密方案，也就是说，<span class="arithmatex">\(E_S(k, m) = k \oplus m\)</span>，<span class="arithmatex">\(D_S(k, c) = k \oplus c\)</span>.</p>
<div class="admonition note">
<p class="admonition-title">Theorem</p>
<p>如果量子可访问伪随机函数是存在的，并且<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\mathcal{F}\)</span><span class="heti-spacing"> </span></span>是一个量子免疫单射陷门函数，<span><span class="arithmatex">\(\mathcal{E_S}\)</span><span class="heti-spacing"> </span></span>是一个量子<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\op{CCA}\)</span><span class="heti-spacing"> </span></span>安全的对称加密方案，那么<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\mathcal{E}\)</span><span class="heti-spacing"> </span></span>是量子<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\op{CCA}\)</span><span class="heti-spacing"> </span></span>安全的<span><span class="heti-spacing"> </span>.</span></p>
<details class="note" open="open">
<summary>Proof</summary>
<p>假定存在能够攻破<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\mathcal{E}\)</span><span class="heti-spacing"> </span></span>的敌手<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(A_Q\)</span>.<span class="heti-spacing"> </span></span>首先从标准的<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\op{CCA}\)</span><span class="heti-spacing"> </span></span>安全博弈开始<span><span class="heti-spacing"> </span>.</span></p>
<ul>
<li>
<p><strong>Game 0</strong><span>:<span class="heti-spacing"> </span></span>定义<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\op{Game}_0\)</span><span class="heti-spacing"> </span></span>为量子敌手<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(A_Q\)</span><span class="heti-spacing"> </span></span>在问题<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\op{Asym-CCA}(\mathcal{E})\)</span><span class="heti-spacing"> </span></span>上的博弈<span><span class="heti-spacing"> </span>.</span> </p>
</li>
<li>
<p><strong>Game 1</strong><span>:<span class="heti-spacing"> </span></span>定义<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\op{Game}_1\)</span><span class="heti-spacing"> </span></span>为如下的博弈：挑战者生成<span><span class="heti-spacing"> </span><span class="arithmatex">\((\sk, \pk) \from G(1^n)\)</span></span>，<span><span class="arithmatex">\(\mathcal{F}\)</span><span class="heti-spacing"> </span></span>定义域上的一个随机元素<span><span class="heti-spacing"> </span><span class="arithmatex">\(r\)</span></span>，<span><span class="arithmatex">\(\mathcal{E_S}\)</span><span class="heti-spacing"> </span></span>的密钥空间上的一个随机密钥<span><span class="heti-spacing"> </span><span class="arithmatex">\(k\)</span></span>，并且计算<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(y = f(\pk, r)\)</span>.<span class="heti-spacing"> </span></span>挑战者可以访问一个值域为<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\mathcal{E_S}\)</span><span class="heti-spacing"> </span></span>的密钥空间的量子可访问随机<span class="heti-skip"><span class="heti-spacing"> </span>Oracle <span class="arithmatex">\(O_q\)</span>.<span class="heti-spacing"> </span></span>之后挑战者将<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\pk\)</span><span class="heti-spacing"> </span></span>发送给<span><span class="heti-spacing"> </span><span class="arithmatex">\(A_Q\)</span></span>，并按如下处理<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(A_Q\)</span><span class="heti-spacing"> </span></span>的查询：</p>
<ul>
<li>
<p>随机<span class="heti-skip"><span class="heti-spacing"> </span>Oracle<span class="heti-spacing"> </span></span>查询以随机<span class="heti-skip"><span class="heti-spacing"> </span>Oracle <span class="arithmatex">\(O_{\op{quant}}\)</span><span class="heti-spacing"> </span></span>的查询进行回复，其将<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\ket{x, y}\)</span><span class="heti-spacing"> </span></span>映射到<span><span class="heti-spacing"> </span><span class="arithmatex">\(\ket{x, y \oplus O_q(f(\pk, x))}\)</span></span></p>
</li>
<li>
<p>对<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\((y', c')\)</span><span class="heti-spacing"> </span></span>的解密查询按如下回复：</p>
<ul>
<li>
<p>如果<span><span class="heti-spacing"> </span><span class="arithmatex">\(y = y'\)</span></span>，则回复<span><span class="heti-spacing"> </span><span class="arithmatex">\(D_S(k, c')\)</span></span></p>
</li>
<li>
<p>如果<span><span class="heti-spacing"> </span><span class="arithmatex">\(y \neq y'\)</span></span>，则回复<span><span class="heti-spacing"> </span><span class="arithmatex">\(D_S(O_q(y'), c')\)</span></span></p>
</li>
</ul>
</li>
<li>
<p>对<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\((m_0, m_1)\)</span><span class="heti-spacing"> </span></span>的挑战查询则是随机选取<span><span class="heti-spacing"> </span><span class="arithmatex">\(b\)</span></span>，回复<span><span class="heti-spacing"> </span><span class="arithmatex">\((y, E_S(k, m_b))\)</span></span></p>
</li>
</ul>
<p>当<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(A_Q\)</span><span class="heti-spacing"> </span></span>回复<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(b'\)</span><span class="heti-spacing"> </span></span>后，比较<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(b\)</span><span class="heti-spacing"> </span></span>和<span><span class="heti-spacing"> </span><span class="arithmatex">\(b'\)</span></span>，如果相等称<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(A_Q\)</span><span class="heti-spacing"> </span></span>胜利<span><span class="heti-spacing"> </span>.</span></p>
<p>因为<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(f\)</span><span class="heti-spacing"> </span></span>是一个单射，并且<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(O_q\)</span><span class="heti-spacing"> </span></span>是随机的，所以<span class="heti-skip"><span class="heti-spacing"> </span>Oracle <span class="arithmatex">\(O_{\op{quant}}\)</span><span class="heti-spacing"> </span></span>是一个真正的随机<span><span class="heti-spacing"> </span>Oracle</span>，并且值域和<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(O_q\)</span><span class="heti-spacing"> </span></span>相同<span class="heti-skip"><span class="heti-spacing"> </span>. <span class="arithmatex">\(A_Q\)</span><span class="heti-spacing"> </span></span>所见的挑战密文<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\((y, c)\)</span><span class="heti-spacing"> </span></span>的分布与<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\op{Game}_0\)</span><span class="heti-spacing"> </span></span>中的分布是相同的<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>此外，如果<span><span class="heti-spacing"> </span><span class="arithmatex">\(O_q(y) = k\)</span></span>，那么其是相对于随机<span class="heti-skip"><span class="heti-spacing"> </span>Oracle <span class="arithmatex">\(O_{\op{quant}}\)</span><span class="heti-spacing"> </span></span>的<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(m_b\)</span><span class="heti-spacing"> </span></span>的一个有效加密<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>对于<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(y \neq y'\)</span><span class="heti-spacing"> </span></span>的情况，解密过程如下：</p>
<div class="arithmatex">\[
    D_S(O_q(y'), c') = D_S(O_{\op{quant}}(f^{-1}(\sk, y')), c') = D^{\op{quant}}(\sk, (y', c'))
\]</div>
<p>其是正确的<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>同样的，对于<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(y = y'\)</span><span class="heti-spacing"> </span></span>的情况，解密依然是正确的<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>因此，若<span><span class="heti-spacing"> </span><span class="arithmatex">\(O_q(y) = k\)</span></span>，那么<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(A_Q\)</span><span class="heti-spacing"> </span></span>在<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\op{Game}_1\)</span><span class="heti-spacing"> </span></span>中的视角与<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\op{Game}_0\)</span><span class="heti-spacing"> </span></span>中的视角是相同的<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>又有如下观察：</p>
<ul>
<li>
<p>挑战查询和解密查询的回复算法都没有向<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(O_q\)</span><span class="heti-spacing"> </span></span>查询过<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(y\)</span><span class="heti-spacing"> </span></span>作为输入的结果</p>
</li>
<li>
<p>每个敌手向<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(O_{\op{quant}}\)</span><span class="heti-spacing"> </span></span>的量子随机<span class="heti-skip"><span class="heti-spacing"> </span>Oracle<span class="heti-spacing"> </span></span>查询都导致了一个挑战者向<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(O_q\)</span><span class="heti-spacing"> </span></span>的量子随机<span class="heti-skip"><span class="heti-spacing"> </span>Oracle<span class="heti-spacing"> </span></span>查询<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>挑战者向<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(O_q\)</span><span class="heti-spacing"> </span></span>查询<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(y\)</span><span class="heti-spacing"> </span></span>的振幅与敌手向<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(O_{\op{quant}}\)</span><span class="heti-spacing"> </span></span>查询<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(r\)</span><span class="heti-spacing"> </span></span>的振幅是相同的<span><span class="heti-spacing"> </span>.</span></p>
</li>
</ul>
<p>设<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\varepsilon\)</span><span class="heti-spacing"> </span></span>所有向<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(O_q\)</span><span class="heti-spacing"> </span></span>做出的查询中<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(y\)</span><span class="heti-spacing"> </span></span>的平方幅度的总和（即<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(y\)</span><span class="heti-spacing"> </span></span>的总查询概率）<span>.<span class="heti-spacing"> </span></span>这与所有<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(A_Q\)</span><span class="heti-spacing"> </span></span>向<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(O_{\op{quant}}\)</span><span class="heti-spacing"> </span></span>做出的查询中<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(r\)</span><span class="heti-spacing"> </span></span>的总查询概率是相同的<span><span class="heti-spacing"> </span>.</span> </p>
<p>接下来构建一个使用量子可访问随机<span class="heti-skip"><span class="heti-spacing"> </span>Oracle <span class="arithmatex">\(O_q\)</span><span class="heti-spacing"> </span></span>的量子算法<span><span class="heti-spacing"> </span><span class="arithmatex">\(B_{\mathcal{F}}^{O_q}\)</span></span>，并且将以<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\varepsilon / q\)</span><span class="heti-spacing"> </span></span>的概率反转<span><span class="heti-spacing"> </span><span class="arithmatex">\(f\)</span></span>，其中<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(q\)</span><span class="heti-spacing"> </span></span>是<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(A_Q\)</span><span class="heti-spacing"> </span></span>做出的随机<span class="heti-skip"><span class="heti-spacing"> </span>Oracle<span class="heti-spacing"> </span></span>查询次数<span class="heti-skip"><span class="heti-spacing"> </span>. <span class="arithmatex">\(B_{\mathcal{F}}^{O_q}\)</span><span class="heti-spacing"> </span></span>以<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\((\pk, y)\)</span><span class="heti-spacing"> </span></span>为输入，目标是输出<span><span class="heti-spacing"> </span><span class="arithmatex">\(r = f^{-1}(\sk, y)\)</span></span>，按如下方法工作：</p>
<ul>
<li>
<p>在<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\mathcal{E_S}\)</span><span class="heti-spacing"> </span></span>的密钥空间上随机生成一个密钥<span><span class="heti-spacing"> </span><span class="arithmatex">\(k\)</span></span>，在<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\{1, \ldots, q\}\)</span><span class="heti-spacing"> </span></span>上随机生成一个数<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(i\)</span>.<span class="heti-spacing"> </span></span>而后将<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\pk\)</span><span class="heti-spacing"> </span></span>发送给<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(A_Q\)</span><span class="heti-spacing"> </span></span>兵扮演挑战者的角色</p>
</li>
<li>
<p>以随机<span class="heti-skip"><span class="heti-spacing"> </span>Oracle <span class="arithmatex">\(O_{\op{quant}}\)</span><span class="heti-spacing"> </span></span>回复随机<span class="heti-skip"><span class="heti-spacing"> </span>Oracle<span class="heti-spacing"> </span></span>查询，其中<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(O_{\op{quant}}\)</span><span class="heti-spacing"> </span></span>将<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\ket{x, y}\)</span><span class="heti-spacing"> </span></span>映射到<span><span class="heti-spacing"> </span><span class="arithmatex">\(\ket{x, y \oplus O_q(f(\pk, x))}\)</span></span></p>
</li>
<li>
<p>对<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\((y', c')\)</span><span class="heti-spacing"> </span></span>的解密查询按如下回复：</p>
<ul>
<li>
<p>如果<span><span class="heti-spacing"> </span><span class="arithmatex">\(y = y'\)</span></span>，则回复<span><span class="heti-spacing"> </span><span class="arithmatex">\(D_S(k, c')\)</span></span></p>
</li>
<li>
<p>如果<span><span class="heti-spacing"> </span><span class="arithmatex">\(y \neq y'\)</span></span>，则回复<span><span class="heti-spacing"> </span><span class="arithmatex">\(D_S(O_q(y'), c')\)</span></span></p>
</li>
</ul>
</li>
<li>
<p>对<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\((m_0, m_1)\)</span><span class="heti-spacing"> </span></span>的挑战查询则是随机选取<span><span class="heti-spacing"> </span><span class="arithmatex">\(b\)</span></span>，回复<span><span class="heti-spacing"> </span><span class="arithmatex">\((y, E_S(k, m_b))\)</span></span></p>
</li>
<li>
<p>在第<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(i\)</span><span class="heti-spacing"> </span></span>次随机<span class="heti-skip"><span class="heti-spacing"> </span>Oracle<span class="heti-spacing"> </span></span>查询时，采样查询得到<span><span class="heti-spacing"> </span><span class="arithmatex">\(r'\)</span></span>，输出<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(r'\)</span><span class="heti-spacing"> </span></span>并终止</p>
</li>
</ul>
<p>比较<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(B_{\mathcal{F}}^{O_q}\)</span><span class="heti-spacing"> </span></span>和<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\op{Game}_1\)</span><span class="heti-spacing"> </span></span>的定义，可以发现<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(A_Q\)</span><span class="heti-spacing"> </span></span>在两种情况下的视角都是一样的，所以<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(A_Q\)</span><span class="heti-spacing"> </span></span>向<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(O_{\op{quant}}\)</span><span class="heti-spacing"> </span></span>查询<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(r\)</span><span class="heti-spacing"> </span></span>的总查询概率为<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\varepsilon\)</span>.<span class="heti-spacing"> </span></span>因此，<span><span class="arithmatex">\(B_{\mathcal{F}}^{O_q}\)</span><span class="heti-spacing"> </span></span>最终输出<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(r\)</span><span class="heti-spacing"> </span></span>的概率为<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\varepsilon / q\)</span>.<span class="heti-spacing"> </span></span>如果假定<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\mathcal{F}\)</span><span class="heti-spacing"> </span></span>对使用量子可访问随机<span class="heti-skip"><span class="heti-spacing"> </span>Oracle<span class="heti-spacing"> </span></span>的量子敌手是安全的，那么<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\varepsilon\)</span><span class="heti-spacing"> </span></span>必然是可忽略的<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>对于签名的情况，这一假设可以用<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\mathcal{F}\)</span><span class="heti-spacing"> </span></span>对不可使用量子可访问随机<span class="heti-skip"><span class="heti-spacing"> </span>Oracle<span class="heti-spacing"> </span></span>的量子敌手是安全的以及伪随机函数存在来替换，并且得到的结论是相同的<span><span class="heti-spacing"> </span>.</span></p>
<p>因为<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\varepsilon\)</span><span class="heti-spacing"> </span></span>是可忽略的，所以<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\op{Game}_1\)</span><span class="heti-spacing"> </span></span>中的<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(O_q(y) = k\)</span><span class="heti-spacing"> </span></span>是可以被改变的，进而得到一个敌手视角中与<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\op{Game}_0\)</span><span class="heti-spacing"> </span></span>相同的博弈<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>而在<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\op{Game}_0\)</span><span class="heti-spacing"> </span></span>和<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\op{Game}_1\)</span><span class="heti-spacing"> </span></span>中，因为只进行了酉变换，测量操作以及经典通信操作，所以<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(A_Q\)</span><span class="heti-spacing"> </span></span>始终处于纯态<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>因为只以可忽略的总查询概率改变了<span class="heti-skip"><span class="heti-spacing"> </span>Oracle<span class="heti-spacing"> </span></span>在一点的值，所以依据引理，这只会以可忽略的概率影响<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\op{Game}_1\)</span><span class="heti-spacing"> </span></span>的输出的分布<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>因此，<span><span class="arithmatex">\(A_Q\)</span><span class="heti-spacing"> </span></span>在<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\op{Game}_1\)</span><span class="heti-spacing"> </span></span>中的成功概率与<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\op{Game}_0\)</span><span class="heti-spacing"> </span></span>中的成功概率之间的差距是可忽略的<span><span class="heti-spacing"> </span>.</span></p>
<p>现在假定<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(A_Q\)</span><span class="heti-spacing"> </span></span>在<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\op{Game}_1\)</span><span class="heti-spacing"> </span></span>中成功的概率是不可忽略的<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>接下来定义一个使用量子可访问随机<span class="heti-skip"><span class="heti-spacing"> </span>Oracle  <span class="arithmatex">\(O_q\)</span><span class="heti-spacing"> </span></span>的量子算法<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(B_{\mathcal{E_S}}^{O_q}\)</span><span class="heti-spacing"> </span></span>来攻破<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\mathcal{E_S}\)</span><span class="heti-spacing"> </span></span>的<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\op{CCA}\)</span><span class="heti-spacing"> </span></span>安全性<span class="heti-skip"><span class="heti-spacing"> </span>. $B_{\mathcal{E_S}}^{O_q}<span class="heti-spacing"> </span></span>按如下工作：</p>
<ul>
<li>
<p>输入<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(1^n\)</span><span class="heti-spacing"> </span></span>时，生成<span><span class="heti-spacing"> </span><span class="arithmatex">\((\pk, \sk) \from G(1^n)\)</span></span>，并且生成随机串<span><span class="heti-spacing"> </span><span class="arithmatex">\(r\)</span></span>，计算<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(y = f(\pk, r)\)</span>.<span class="heti-spacing"> </span></span>将<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\pk\)</span><span class="heti-spacing"> </span></span>发送给<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(A_Q\)</span><span class="heti-spacing"> </span></span>并且充当挑战者的角色</p>
</li>
<li>
<p>以随机<span class="heti-skip"><span class="heti-spacing"> </span>Oracle <span class="arithmatex">\(O_{\op{quant}}\)</span><span class="heti-spacing"> </span></span>回复随机<span class="heti-skip"><span class="heti-spacing"> </span>Oracle<span class="heti-spacing"> </span></span>查询，其中<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(O_{\op{quant}}\)</span><span class="heti-spacing"> </span></span>将<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\ket{x, y}\)</span><span class="heti-spacing"> </span></span>映射到<span><span class="heti-spacing"> </span><span class="arithmatex">\(\ket{x, y \oplus O_q(f(\pk, x))}\)</span></span></p>
</li>
<li>
<p>对<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\((y', c')\)</span><span class="heti-spacing"> </span></span>的解密查询按如下回复：</p>
<ul>
<li>
<p>如果<span><span class="heti-spacing"> </span><span class="arithmatex">\(y = y'\)</span></span>，则向<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\mathcal{E_S}\)</span><span class="heti-spacing"> </span></span>挑战者查询解密<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(D_S(k, c')\)</span><span class="heti-spacing"> </span></span>以得到<span><span class="heti-spacing"> </span><span class="arithmatex">\(m'\)</span></span>，并回复<span><span class="heti-spacing"> </span><span class="arithmatex">\(m'\)</span></span></p>
</li>
<li>
<p>如果<span><span class="heti-spacing"> </span><span class="arithmatex">\(y \neq y'\)</span></span>，则回复<span><span class="heti-spacing"> </span><span class="arithmatex">\(D_S(O_q(y'), c')\)</span></span></p>
</li>
</ul>
</li>
<li>
<p>对<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\((m_0, m_1)\)</span><span class="heti-spacing"> </span></span>的挑战查询则是通过转发<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\mathcal{E_S}\)</span><span class="heti-spacing"> </span></span>的信息对<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>当挑战者回复<span><span class="heti-spacing"> </span><span class="arithmatex">\(c\)</span></span>（存在<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(b\)</span><span class="heti-spacing"> </span></span>使其与<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(E_S(k, m_b)\)</span><span class="heti-spacing"> </span></span>相等）时，返回<span><span class="heti-spacing"> </span><span class="arithmatex">\((y, c)\)</span></span></p>
</li>
<li>
<p>当<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(A_Q\)</span><span class="heti-spacing"> </span></span>回复<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(b'\)</span><span class="heti-spacing"> </span></span>后，输出<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(b'\)</span><span class="heti-spacing"> </span></span>并停机</p>
</li>
</ul>
<p>比较<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(B_{\mathcal{E_S}}^{O_q}\)</span><span class="heti-spacing"> </span></span>和<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\op{Game}_1\)</span><span class="heti-spacing"> </span></span>的定义，可以发现<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(A_Q\)</span><span class="heti-spacing"> </span></span>在两种情况下的视角是一样的，所以<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(A_Q\)</span><span class="heti-spacing"> </span></span>的成功概率时不可忽略的<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>如果<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(A_Q\)</span><span class="heti-spacing"> </span></span>成功，也就是说其输出了<span><span class="heti-spacing"> </span><span class="arithmatex">\(b\)</span></span>，那么<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(B_{\mathcal{E_S}}^{O_q}\)</span><span class="heti-spacing"> </span></span>也成功了，这一使用了量子可访问随机<span class="heti-skip"><span class="heti-spacing"> </span>Oracle<span class="heti-spacing"> </span></span>的算法攻破了<span><span class="heti-spacing"> </span><span class="arithmatex">\(\mathcal{E_S}\)</span></span>，与<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\mathcal{E_S}\)</span><span class="heti-spacing"> </span></span>对使用量子可访问随机<span class="heti-skip"><span class="heti-spacing"> </span>Oracle<span class="heti-spacing"> </span></span>的量子敌手的<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\op{CCA}\)</span><span class="heti-spacing"> </span></span>安全性相矛盾<span><span class="heti-spacing"> </span>.</span> </p>
<p>因此，<span><span class="arithmatex">\(A_Q\)</span><span class="heti-spacing"> </span></span>在<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\op{Game}_1\)</span><span class="heti-spacing"> </span></span>中的成功概率是可忽略的，进而<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\op{Game}_0\)</span><span class="heti-spacing"> </span></span>中的成功概率也是可忽略的<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>也就证明了所有的多项式时间量子算法在攻破<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\mathcal{E}\)</span><span class="heti-spacing"> </span></span>的<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\op{CCA}\)</span><span class="heti-spacing"> </span></span>安全性上的优势是可忽略的，所以<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\mathcal{E}\)</span><span class="heti-spacing"> </span></span>是<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\op{CCA}\)</span><span class="heti-spacing"> </span></span>安全的<span><span class="heti-spacing"> </span>.</span> </p>
</li>
</ul>
</details>
</div>
<p>简要解释一下为什么<span class="heti-skip"><span class="heti-spacing"> </span>BR<span class="heti-spacing"> </span></span>加密的<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\op{CPA}\)</span><span class="heti-spacing"> </span></span>安全性是混合加密方案的<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\op{CCA}\)</span><span class="heti-spacing"> </span></span>安全性的一个特殊情况<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>在上述证明中<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(B_{\mathcal{E_S}}\)</span><span class="heti-spacing"> </span></span>只在回复<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(A_Q\)</span><span class="heti-spacing"> </span></span>的解密查询时才会查询其解密<span><span class="heti-spacing"> </span>Oracle</span>，并且从未进行过加密查询<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>因此，只要<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(A_Q\)</span><span class="heti-spacing"> </span></span>不进行解密查询，那么<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(B_{\mathcal{E_S}}\)</span><span class="heti-spacing"> </span></span>就只会进行挑战查询<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>如果只关心<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\mathcal{E}\)</span><span class="heti-spacing"> </span></span>的<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\op{CPA}\)</span><span class="heti-spacing"> </span></span>安全性，那么就只需要<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(E_S\)</span><span class="heti-spacing"> </span></span>对只能进行挑战查询的敌手是安全的<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>更进一步，如果只允许<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(A_Q\)</span><span class="heti-spacing"> </span></span>进行挑战查询。并且限制消息长度为<span><span class="heti-spacing"> </span><span class="arithmatex">\(n\)</span></span>，那么<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(E_S\)</span><span class="heti-spacing"> </span></span>只需要对只能以特定长度的消息进行挑战查询的敌手是安全的即可<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>而这恰恰就是一次一密无条件安全的情况，所以<span class="heti-skip"><span class="heti-spacing"> </span>BR<span class="heti-spacing"> </span></span>加密的<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\op{CPA}\)</span><span class="heti-spacing"> </span></span>安全性是混合加密方案的<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\op{CCA}\)</span><span class="heti-spacing"> </span></span>安全性的一个特殊情况<span><span class="heti-spacing"> </span>.</span></p>
<h2 id="appendix">Appendix<a class="headerlink" href="#appendix" title="Permanent link">¶</a></h2>
<h3 id="definition">Definition<a class="headerlink" href="#definition" title="Permanent link">¶</a></h3>
<div class="admonition info">
<p class="admonition-title">Definition</p>
<p><strong>(Trapdoor Permutation)</strong> 陷门置换是一个函数三元组<span><span class="heti-spacing"> </span><span class="arithmatex">\(\mathcal{F} = (G, f, f^{-1})\)</span></span>，其中：</p>
<ul>
<li>
<p><span><span class="arithmatex">\(G(1^n)\)</span><span class="heti-spacing"> </span></span>生成密钥对<span><span class="heti-spacing"> </span><span class="arithmatex">\((\sk, \pk)\)</span></span></p>
</li>
<li>
<p><span><span class="arithmatex">\(f(\pk, \cdot)\)</span><span class="heti-spacing"> </span></span>是一个对所有<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\pk\)</span><span class="heti-spacing"> </span></span>的置换</p>
</li>
<li>
<p>对于所有由<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(G\)</span><span class="heti-spacing"> </span></span>生成的<span><span class="heti-spacing"> </span><span class="arithmatex">\((\sk, \pk)\)</span></span>，<span><span class="arithmatex">\(f^{-1}(\sk, \cdot)\)</span><span class="heti-spacing"> </span></span>是<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(f(\pk, \cdot)\)</span><span class="heti-spacing"> </span></span>的逆，也就有<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(f^{-1}(\sk, f(\pk, x)) = x\)</span><span class="heti-spacing"> </span></span>以及<span><span class="heti-spacing"> </span><span class="arithmatex">\(f(\pk, f^{-1}(\sk, y)) = y\)</span></span></p>
</li>
</ul>
</div>
<p>对陷门置换<span><span class="heti-spacing"> </span><span class="arithmatex">\(\mathcal{F}\)</span></span>，定义问题<span><span class="heti-spacing"> </span><span class="arithmatex">\(\op{Inv}(\mathcal{F}) = (\op{Game}(\mathcal{F}), 0)\)</span></span>，其中<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\op{Game}(\mathcal{F})\)</span><span class="heti-spacing"> </span></span>是量子敌手<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(A\)</span><span class="heti-spacing"> </span></span>和挑战者<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\op{Ch}\)</span><span class="heti-spacing"> </span></span>之间的如下的博弈：</p>
<ul>
<li>
<p><span><span class="arithmatex">\(\op{Ch}\)</span><span class="heti-spacing"> </span></span>以<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(n\)</span><span class="heti-spacing"> </span></span>为输入，运行<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(G(1^n)\)</span><span class="heti-spacing"> </span></span>生成密钥对<span><span class="heti-spacing"> </span><span class="arithmatex">\((\sk, \pk)\)</span></span>，并在<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(f(\pk, \cdot)\)</span><span class="heti-spacing"> </span></span>的值域上生成一个随机元素<span><span class="heti-spacing"> </span><span class="arithmatex">\(y\)</span></span>，将<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\((\pk, y)\)</span><span class="heti-spacing"> </span></span>发送给<span><span class="heti-spacing"> </span><span class="arithmatex">\(A\)</span></span></p>
</li>
<li>
<p><span><span class="arithmatex">\(A\)</span><span class="heti-spacing"> </span></span>被允许进行量子随机<span class="heti-skip"><span class="heti-spacing"> </span>Oracle<span class="heti-spacing"> </span></span>查询<span><span class="heti-spacing"> </span><span class="arithmatex">\(O(\cdot)\)</span></span></p>
</li>
<li>
<p>当<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(A\)</span><span class="heti-spacing"> </span></span>输出<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(x\)</span><span class="heti-spacing"> </span></span>时，当且仅当<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(f(\pk, x) = y\)</span><span class="heti-spacing"> </span></span>时，<span><span class="arithmatex">\(\op{Ch}\)</span><span class="heti-spacing"> </span></span>输出<span><span class="heti-spacing"> </span>1</span></p>
</li>
</ul>
<div class="admonition info">
<p class="admonition-title">Definition</p>
<p>如果<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\op{Inv}(\mathcal{F})\)</span><span class="heti-spacing"> </span></span>对量子计算机是困难的，那么<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\mathcal{F}\)</span><span class="heti-spacing"> </span></span>对量子敌手具有安全性<span><span class="heti-spacing"> </span>.</span></p>
</div>
<div class="admonition info">
<p class="admonition-title">Definition</p>
<p><strong>(Preimage Sampleable Trapdoor Function)</strong> 具有预像可采样性质的陷门碰撞抗性哈希函数是具有如下性质的函数四元组<span><span class="heti-spacing"> </span><span class="arithmatex">\(\mathcal{F} = (G, \op{Sample}, f, f^{-1})\)</span></span>：</p>
<ul>
<li>
<p><span><span class="arithmatex">\(G(1^n)\)</span><span class="heti-spacing"> </span></span>生成密钥对<span><span class="heti-spacing"> </span><span class="arithmatex">\((\sk, \pk)\)</span></span></p>
</li>
<li>
<p><span><span class="arithmatex">\(f(\pk, \cdot)\)</span><span class="heti-spacing"> </span></span>的定义域为<span><span class="heti-spacing"> </span><span class="arithmatex">\(D\)</span></span>，值域为<span><span class="heti-spacing"> </span><span class="arithmatex">\(R\)</span></span></p>
</li>
<li>
<p><span><span class="arithmatex">\(\op{Sample}(1^n)\)</span><span class="heti-spacing"> </span></span>从<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(D\)</span><span class="heti-spacing"> </span></span>上的某一分布进行采样，使得对于任意的<span><span class="heti-spacing"> </span><span class="arithmatex">\(\pk\)</span></span>，<span><span class="arithmatex">\(f(\pk, \op{Sample}(1^n))\)</span><span class="heti-spacing"> </span></span>与均匀分布的变差距离不超过<span><span class="heti-spacing"> </span><span class="arithmatex">\(\varepsilon_{\op{Sample}}\)</span></span></p>
</li>
<li>
<p><span><span class="arithmatex">\(f^{-1}(\sk, y)\)</span><span class="heti-spacing"> </span></span>生成满足<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(f(\pk, x) = y\)</span><span class="heti-spacing"> </span></span>的<span><span class="heti-spacing"> </span><span class="arithmatex">\(x\)</span></span>，且分布与给定<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(f(\pk, x) = y\)</span><span class="heti-spacing"> </span></span>的<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\op{Sample}()\)</span><span class="heti-spacing"> </span></span>的条件分布之间的距离不超过<span><span class="heti-spacing"> </span><span class="arithmatex">\(\varepsilon_{\op{pre}}\)</span></span>，其中<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\varepsilon_{\op{pre}}\)</span><span class="heti-spacing"> </span></span>是可忽略的</p>
</li>
<li>
<p>原像最小熵：对所有<span><span class="heti-spacing"> </span><span class="arithmatex">\(y \in R\)</span></span>，给定<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(f(\pk, x) = y\)</span><span class="heti-spacing"> </span></span>的<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\op{Sample}(1^n)\)</span><span class="heti-spacing"> </span></span>的条件分布中的任何元素的概率都小于<span><span class="heti-spacing"> </span><span class="arithmatex">\(\varepsilon_{\op{prob}}\)</span></span>，其中<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\varepsilon_{\op{prob}}\)</span><span class="heti-spacing"> </span></span>是可忽略的</p>
</li>
</ul>
</div>
<p>对于<span><span class="heti-spacing"> </span><span class="arithmatex">\(\op{PSF}\)</span></span>，除了定义问题<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\op{Inv}\)</span><span class="heti-spacing"> </span></span>之外，还会定义问题<span><span class="heti-spacing"> </span><span class="arithmatex">\(\op{Col} = (\op{Game}(\mathcal{F}), 0)\)</span></span>，其中<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\op{Game}(\mathcal{F})\)</span><span class="heti-spacing"> </span></span>是量子敌手<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(A\)</span><span class="heti-spacing"> </span></span>和挑战者<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\op{Ch}\)</span><span class="heti-spacing"> </span></span>之间的如下的博弈：</p>
<ul>
<li>
<p>挑战者<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\op{Ch}\)</span><span class="heti-spacing"> </span></span>以<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(n\)</span><span class="heti-spacing"> </span></span>为输入，运行<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(G(1^n)\)</span><span class="heti-spacing"> </span></span>生成密钥对<span><span class="heti-spacing"> </span><span class="arithmatex">\((\sk, \pk)\)</span></span>，将<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\pk\)</span><span class="heti-spacing"> </span></span>发送给<span><span class="heti-spacing"> </span><span class="arithmatex">\(A\)</span></span></p>
</li>
<li>
<p><span><span class="arithmatex">\(A\)</span><span class="heti-spacing"> </span></span>被允许进行量子随机<span class="heti-skip"><span class="heti-spacing"> </span>Oracle<span class="heti-spacing"> </span></span>查询<span><span class="heti-spacing"> </span><span class="arithmatex">\(O(\cdot)\)</span></span></p>
</li>
<li>
<p>当<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(A\)</span><span class="heti-spacing"> </span></span>输出<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\((x_1, x_2)\)</span><span class="heti-spacing"> </span></span>时，当且仅当<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(x_1 \neq x_2\)</span><span class="heti-spacing"> </span></span>且<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(f(\pk, x_1) = f(\pk, x_2)\)</span><span class="heti-spacing"> </span></span>时，<span><span class="arithmatex">\(\op{Ch}\)</span><span class="heti-spacing"> </span></span>输出<span><span class="heti-spacing"> </span>1</span></p>
</li>
</ul>
<div class="admonition info">
<p class="admonition-title">Definition</p>
<p>如果<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\op{Inv}(\mathcal{F})\)</span><span class="heti-spacing"> </span></span>和<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\op{Col}(\mathcal{F})\)</span><span class="heti-spacing"> </span></span>对量子计算机均是困难的，那么<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\mathcal{F}\)</span><span class="heti-spacing"> </span></span>对量子敌手具有安全性<span><span class="heti-spacing"> </span>.</span></p>
</div>
<div class="admonition info">
<p class="admonition-title">Definition</p>
<p><strong>(Signature Scheme)</strong> 随机<span class="heti-skip"><span class="heti-spacing"> </span>Oracle<span class="heti-spacing"> </span></span>签名方案是一个函数三元组<span><span class="heti-spacing"> </span><span class="arithmatex">\(\mathcal{S} = (G, S^O, V^O)\)</span></span>，其中：</p>
<ul>
<li>
<p><span><span class="arithmatex">\(O\)</span><span class="heti-spacing"> </span></span>是一个随机<span><span class="heti-spacing"> </span>Oracle</span></p>
</li>
<li>
<p><span><span class="arithmatex">\(G(1^n)\)</span><span class="heti-spacing"> </span></span>生成密钥对<span><span class="heti-spacing"> </span><span class="arithmatex">\((\sk, \pk)\)</span></span>，<span><span class="arithmatex">\(\sk\)</span><span class="heti-spacing"> </span></span>是签名者的私钥，<span><span class="arithmatex">\(\pk\)</span><span class="heti-spacing"> </span></span>是一个公钥</p>
</li>
<li>
<p><span><span class="arithmatex">\(S^O(\sk, m)\)</span><span class="heti-spacing"> </span></span>是签名算法，其输出一个签名<span><span class="heti-spacing"> </span><span class="arithmatex">\(\sigma\)</span></span></p>
</li>
<li>
<p><span><span class="arithmatex">\(V^O(\pk, m, \sigma)\)</span><span class="heti-spacing"> </span></span>是验证算法，其输出<span class="heti-skip"><span class="heti-spacing"> </span>1<span class="heti-spacing"> </span></span>当且仅当<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\sigma\)</span><span class="heti-spacing"> </span></span>是<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(m\)</span><span class="heti-spacing"> </span></span>的合法签名，要求对所有<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(m\)</span><span class="heti-spacing"> </span></span>和<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(G\)</span><span class="heti-spacing"> </span></span>生成的<span><span class="heti-spacing"> </span><span class="arithmatex">\((\sk, \pk)\)</span></span>，<span class="arithmatex">\(V^O(\pk, m, S^O(\sk, m)) = 1\)</span></p>
</li>
</ul>
</div>
<p>对签名算法<span><span class="heti-spacing"> </span><span class="arithmatex">\(\mathcal{S}\)</span></span>，定义问题<span><span class="heti-spacing"> </span><span class="arithmatex">\(\op{Sig-Forge}(\mathcal{S}) = (\op{Game}(\mathcal{S}), 0)\)</span></span>，其中<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\op{Game}(\mathcal{S})\)</span><span class="heti-spacing"> </span></span>是量子敌手<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(A\)</span><span class="heti-spacing"> </span></span>和挑战者<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\op{Ch}^O\)</span><span class="heti-spacing"> </span></span>之间的如下的博弈：</p>
<ul>
<li>
<p><span><span class="arithmatex">\(\op{Ch}^O\)</span><span class="heti-spacing"> </span></span>以<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(n\)</span><span class="heti-spacing"> </span></span>为输入，运行<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(G(1^n)\)</span><span class="heti-spacing"> </span></span>生成密钥对<span><span class="heti-spacing"> </span><span class="arithmatex">\((\sk, \pk)\)</span></span>，并将<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\pk\)</span><span class="heti-spacing"> </span></span>发送给<span><span class="heti-spacing"> </span><span class="arithmatex">\(A\)</span></span></p>
</li>
<li>
<p><span><span class="arithmatex">\(A\)</span><span class="heti-spacing"> </span></span>被允许进行量子随机<span class="heti-skip"><span class="heti-spacing"> </span>Oracle<span class="heti-spacing"> </span></span>查询<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(O(\cdot)\)</span><span class="heti-spacing"> </span></span>和向<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\op{Ch}^O\)</span><span class="heti-spacing"> </span></span>进行经典签名查询<span><span class="heti-spacing"> </span><span class="arithmatex">\(S^O(\sk, \cdot)\)</span></span></p>
</li>
<li>
<p>当<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(A\)</span><span class="heti-spacing"> </span></span>输出一个可能的伪造签名<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\((m, \sigma)\)</span><span class="heti-spacing"> </span></span>时，当且仅当<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(A\)</span><span class="heti-spacing"> </span></span>从未查询过<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(m\)</span><span class="heti-spacing"> </span></span>的签名且<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(V^O(\pk, m, \sigma) = 1\)</span><span class="heti-spacing"> </span></span>时，<span><span class="arithmatex">\(\op{Ch}^O\)</span><span class="heti-spacing"> </span></span>输出<span><span class="heti-spacing"> </span>1</span></p>
</li>
</ul>
<div class="admonition info">
<p class="admonition-title">Definition</p>
<p>如果<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\op{Sig-Forge}(\mathcal{S})\)</span><span class="heti-spacing"> </span></span>对量子计算机是困难的，那么<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\mathcal{S}\)</span><span class="heti-spacing"> </span></span>对量子敌手具有安全性<span><span class="heti-spacing"> </span>.</span></p>
</div>
<div class="admonition info">
<p class="admonition-title">Definition</p>
<p><strong>(Symmetric Key Encryption Scheme)</strong> 对称密钥随机<span class="heti-skip"><span class="heti-spacing"> </span>Oracle<span class="heti-spacing"> </span></span>加密方案是一个函数二元组<span><span class="heti-spacing"> </span><span class="arithmatex">\(\mathcal{E} = (E^O, D^O)\)</span></span>，其中：</p>
<ul>
<li>
<p><span><span class="arithmatex">\(E^O(k, m)\)</span><span class="heti-spacing"> </span></span>生成密文<span><span class="heti-spacing"> </span><span class="arithmatex">\(c\)</span></span></p>
</li>
<li>
<p><span><span class="arithmatex">\(D^O(k, c)\)</span><span class="heti-spacing"> </span></span>计算出对应的明文<span><span class="heti-spacing"> </span><span class="arithmatex">\(m\)</span></span>，要求<span><span class="heti-spacing"> </span><span class="arithmatex">\(D^O(k, E^O(k, m)) = m\)</span></span></p>
</li>
</ul>
</div>
<p>对<span><span class="heti-spacing"> </span><span class="arithmatex">\(\mathcal{E}\)</span></span>，定义问题<span><span class="heti-spacing"> </span><span class="arithmatex">\(\op{Sym-CCA}(\mathcal{E}) = (\op{Game}(\mathcal{E}), \frac{1}{2})\)</span></span>，其中<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\op{Game}(\mathcal{E})\)</span><span class="heti-spacing"> </span></span>是量子敌手<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(A\)</span><span class="heti-spacing"> </span></span>和挑战者<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\op{Ch}^O\)</span><span class="heti-spacing"> </span></span>之间的如下的博弈：</p>
<ul>
<li>
<p><span><span class="arithmatex">\(\op{Ch}^O\)</span><span class="heti-spacing"> </span></span>以<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(n\)</span><span class="heti-spacing"> </span></span>为输入，随机生成长度为<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(n\)</span><span class="heti-spacing"> </span></span>的密钥<span><span class="heti-spacing"> </span><span class="arithmatex">\(k\)</span></span>，并将<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(k\)</span><span class="heti-spacing"> </span></span>发送给<span><span class="heti-spacing"> </span><span class="arithmatex">\(A\)</span></span></p>
</li>
<li>
<p><span><span class="arithmatex">\(A\)</span><span class="heti-spacing"> </span></span>被允许进行量子随机<span class="heti-skip"><span class="heti-spacing"> </span>Oracle<span class="heti-spacing"> </span></span>查询<span><span class="heti-spacing"> </span><span class="arithmatex">\(O(\cdot)\)</span></span>，经典加密查询<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(E^O(k, \cdot)\)</span><span class="heti-spacing"> </span></span>和经典解密查询<span><span class="heti-spacing"> </span><span class="arithmatex">\(D^O(k, \cdot)\)</span>.</span> </p>
</li>
<li>
<p>此外<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(A\)</span><span class="heti-spacing"> </span></span>被允许进行一次经典挑战查询，其向<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\op{Ch}^O\)</span><span class="heti-spacing"> </span></span>发送一对消息<span><span class="heti-spacing"> </span><span class="arithmatex">\((m_0, m_1)\)</span></span>，<span><span class="arithmatex">\(\op{Ch}^O\)</span><span class="heti-spacing"> </span></span>随机选取<span><span class="heti-spacing"> </span><span class="arithmatex">\(b\)</span></span>，计算<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(c = E^O(k, m_b)\)</span><span class="heti-spacing"> </span></span>并将<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(c\)</span><span class="heti-spacing"> </span></span>发送给<span><span class="heti-spacing"> </span><span class="arithmatex">\(A\)</span></span></p>
</li>
<li>
<p>当<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(A\)</span><span class="heti-spacing"> </span></span>输出一个比特<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(b'\)</span><span class="heti-spacing"> </span></span>时，当且仅当<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(b = b'\)</span><span class="heti-spacing"> </span></span>并且在挑战查询后<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(A\)</span><span class="heti-spacing"> </span></span>从未查询过<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(c\)</span><span class="heti-spacing"> </span></span>的解密<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(D^O(k, c)\)</span><span class="heti-spacing"> </span></span>时，<span><span class="arithmatex">\(\op{Ch}^O\)</span><span class="heti-spacing"> </span></span>输出<span><span class="heti-spacing"> </span>1</span></p>
</li>
</ul>
<div class="admonition info">
<p class="admonition-title">Definition</p>
<p>如果<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\op{Sym-CCA}(\mathcal{E})\)</span><span class="heti-spacing"> </span></span>对量子计算机是困难的，那么<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\mathcal{E}\)</span><span class="heti-spacing"> </span></span>对量子敌手具有<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\op{CCA}\)</span><span class="heti-spacing"> </span></span>安全性<span><span class="heti-spacing"> </span>.</span></p>
</div>
<div class="admonition info">
<p class="admonition-title">Definition</p>
<p><strong>(Asymmetric Key Encryption Scheme)</strong> 非对称密钥加密方案是一个函数三元组<span><span class="heti-spacing"> </span><span class="arithmatex">\(\mathcal{E} = (G, E^O, D^O)\)</span></span>，其中：</p>
<ul>
<li>
<p><span><span class="arithmatex">\(G(1^n)\)</span><span class="heti-spacing"> </span></span>生成密钥对<span><span class="heti-spacing"> </span><span class="arithmatex">\((\sk, \pk)\)</span></span></p>
</li>
<li>
<p><span><span class="arithmatex">\(E^O(\pk, m)\)</span><span class="heti-spacing"> </span></span>生成密文<span><span class="heti-spacing"> </span><span class="arithmatex">\(c\)</span></span></p>
</li>
<li>
<p><span><span class="arithmatex">\(D^O(\sk, c)\)</span><span class="heti-spacing"> </span></span>计算出对应的明文<span><span class="heti-spacing"> </span><span class="arithmatex">\(m\)</span></span>，要求<span><span class="heti-spacing"> </span><span class="arithmatex">\(D^O(\sk, E^O(\pk, m)) = m\)</span></span></p>
</li>
</ul>
</div>
<p>对<span><span class="heti-spacing"> </span><span class="arithmatex">\(\mathcal{E}\)</span></span>，定义问题<span><span class="heti-spacing"> </span><span class="arithmatex">\(\op{Asym-CCA}(\mathcal{E}) = (\op{Game}(\mathcal{E}), \frac{1}{2})\)</span></span>，其中<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\op{Game}(\mathcal{E})\)</span><span class="heti-spacing"> </span></span>是量子敌手<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(A\)</span><span class="heti-spacing"> </span></span>和挑战者<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\op{Ch}^O\)</span><span class="heti-spacing"> </span></span>之间的如下的博弈：</p>
<ul>
<li>
<p><span><span class="arithmatex">\(\op{Ch}^O\)</span><span class="heti-spacing"> </span></span>以<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(n\)</span><span class="heti-spacing"> </span></span>为输入，运行<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(G(1^n)\)</span><span class="heti-spacing"> </span></span>生成密钥对<span><span class="heti-spacing"> </span><span class="arithmatex">\((\sk, \pk)\)</span></span>，并将<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\pk\)</span><span class="heti-spacing"> </span></span>发送给<span><span class="heti-spacing"> </span><span class="arithmatex">\(A\)</span></span></p>
</li>
<li>
<p><span><span class="arithmatex">\(A\)</span><span class="heti-spacing"> </span></span>被允许进行量子随机<span class="heti-skip"><span class="heti-spacing"> </span>Oracle<span class="heti-spacing"> </span></span>查询<span><span class="heti-spacing"> </span><span class="arithmatex">\(O(\cdot)\)</span></span>，经典加密查询<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(E^O(\pk, \cdot)\)</span><span class="heti-spacing"> </span></span>和经典解密查询<span><span class="heti-spacing"> </span><span class="arithmatex">\(D^O(\sk, \cdot)\)</span>.</span></p>
</li>
<li>
<p>此外<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(A\)</span><span class="heti-spacing"> </span></span>被允许进行一次经典挑战查询，其向<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\op{Ch}^O\)</span><span class="heti-spacing"> </span></span>发送一对消息<span><span class="heti-spacing"> </span><span class="arithmatex">\((m_0, m_1)\)</span></span>，<span><span class="arithmatex">\(\op{Ch}^O\)</span><span class="heti-spacing"> </span></span>随机选取<span><span class="heti-spacing"> </span><span class="arithmatex">\(b\)</span></span>，计算<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(c = E^O(\pk, m_b)\)</span><span class="heti-spacing"> </span></span>并将<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(c\)</span><span class="heti-spacing"> </span></span>发送给<span><span class="heti-spacing"> </span><span class="arithmatex">\(A\)</span></span></p>
</li>
<li>
<p>当<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(A\)</span><span class="heti-spacing"> </span></span>输出一个比特<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(b'\)</span><span class="heti-spacing"> </span></span>时，当且仅当<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(b = b'\)</span><span class="heti-spacing"> </span></span>并且在挑战查询后<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(A\)</span><span class="heti-spacing"> </span></span>从未查询过<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(c\)</span><span class="heti-spacing"> </span></span>的解密<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(D^O(\sk, c)\)</span><span class="heti-spacing"> </span></span>时，<span><span class="arithmatex">\(\op{Ch}^O\)</span><span class="heti-spacing"> </span></span>输出<span><span class="heti-spacing"> </span>1</span></p>
</li>
</ul>
<div class="admonition info">
<p class="admonition-title">Definition</p>
<p>如果<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\op{Asym-CCA}(\mathcal{E})\)</span><span class="heti-spacing"> </span></span>对量子计算机是困难的，那么<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\mathcal{E}\)</span><span class="heti-spacing"> </span></span>对量子敌手具有<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\op{CCA}\)</span><span class="heti-spacing"> </span></span>安全性<span><span class="heti-spacing"> </span>.</span></p>
</div>
</article>
</div>
</div>
<a class="md-top md-icon" data-md-component="top" hidden="" href="#">
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12Z"></path></svg>
            回到页面顶部
          </a>
</main>
<footer class="md-footer">
<div class="md-footer-meta md-typeset">
<div class="md-footer-meta__inner md-grid">
<div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" rel="noopener" target="_blank">
      Material for MkDocs
    </a>
</div>
</div>
</div>
</footer>
</div>
<div class="md-dialog" data-md-component="dialog">
<div class="md-dialog__inner md-typeset"></div>
</div>
<script id="__config" type="application/json">{"base": "../..", "features": ["content.code.annotate", "navigation.tracking", "navigation.tabs", "navigation.indexes", "navigation.top"], "search": "../../assets/javascripts/workers/search.e5c33ebb.min.js", "translations": {"clipboard.copied": "\u5df2\u590d\u5236", "clipboard.copy": "\u590d\u5236", "search.result.more.one": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.more.other": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 # \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.none": "\u6ca1\u6709\u627e\u5230\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.one": "\u627e\u5230 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.other": "# \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.placeholder": "\u952e\u5165\u4ee5\u5f00\u59cb\u641c\u7d22", "search.result.term.missing": "\u7f3a\u5c11", "select.version": "\u9009\u62e9\u5f53\u524d\u7248\u672c"}}</script>
<script src="../../assets/javascripts/bundle.ba449ae6.min.js"></script>
<script src="../../javascripts/mathjax.js"></script>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</body>
</html>