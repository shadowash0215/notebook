# **CSAPP:深入理解计算机系统**

## *1.Overview*
程序就是由值0和1组成的位，又称 *比特* (bit)，8个位被组织成一组，称为 *字节* (byte).  
只由**ASCII**字符构成的文件称为 *文本文件* ，所有其他文件都称为 *二进制文件* .  

- GCC编译器翻译C程序文件到可执行文件的四个阶段:  
    - *预处理阶段* :预处理器(cpp)依据预处理指令进行文本替换，生成 .i 文件.  
    - *编译阶段* :编译器(ccl)将 .i 文件翻译为 .s 文件，其包含一个汇编语言程序.  
    - *汇编阶段* :汇编器(as)将.s文件翻译为机器语言指令，并将其打包成一种叫做 *可重定位目标程序* (reloctable object program)的格式，并将结果保存在 .o 文件中. .o 文件是二进制文件.  
    - *链接阶段* :链接器(ld)负责将其他 .o 文件(标准库的函数、自己编写的其他程序等)与我们汇编阶段得到的 .o 文件合并，从而得到可执行文件.  
gcc编译命令行参考此篇文章 :[GCC基本使用](https://zhuanlan.zhihu.com/p/404682058)  

系统的硬件组成 :  
- 总线 :携带信息字节并负责在各个部件间传递，常被设计为传送定长的字节块，即 *字* (word)，字中的字节长(即 *字长* )是一个基本的系统参数，各个系统中都不尽相同，大多数为4(32位)或8(64位).  
- I/O 设备 :系统与外界联系的通道.每个 I/O 设备都通过一个 *控制器* 或 *适配器* 与 I/O 总线相连，两者的区别在于封装方式.控制器是 I/O 设备或系统主印制电路板( *主板* )上的芯片组，适配器是一块插在主板插槽上的卡.  
- 主存 :临时存储设备，在处理器执行程序时，用来存放程序和程序处理的数据.物理层面，主存是由一组 *动态随机存取存储器* (DRAM)芯片组成的.从逻辑上来说，存储器是一个线性的字节数组，每个字节有唯一的地址，从0开始.  
- 处理器 : *中央处理单元* (CPU)，简称 *处理器* ，是解释(或 *执行* )存储在主存中指令的引擎.核心是一个大小为一个字的存储设备(或 *寄存器* )，称为 *程序计数器* (PC).**在任何时刻，PC都指向主存中的某条机器语言指令(即含有该条指令的地址).**  
处理器是按照 *指令集架构* 决定的指令执行模型来进行操作，相邻执行的指令内存中未必相邻.  
指令指示的简单操作围绕着主存、*寄存器文件* (register file)和 *算术/逻辑单元* (ALU)进行.寄存器文件是一个小的存储设备由，一些单个字长的寄存器组成，每个寄存器名字唯一. ALU 计算新的数据和地址值.  
- 一些简单操作的例子 :  
    - *加载* :从主存复制一个字节或一个字到寄存器，以覆盖寄存器原来的内容.  
    - *存储* :从寄存器复制一个字节或者一个字到主存的某个位置，以覆盖这个位置上原来的内容.  
    - *操作* :把两个寄存器的内容复制到 ALU ， ALU 对这两个字做算术运算，并将结果存放到一个寄存器中，以覆盖该寄存器中原来的内容.  
    - *跳转* :从指令本身中抽取一个字，并将这个字复制到 PC 中，以覆盖 PC 中原来的值.  

处理器的指令集架构与微体系结构是有区别的，前者描述每条机器代码指令的效果，后者描述处理器实际上如何实现.  

- **高速缓存存储器** (cache memory，简称为 cache 或高速缓存) :作为暂时的集结区域，存放处理器近期可能需要的信息.  
![1-1 高速缓存存储器](pictures/1-1%20%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98%E5%AD%98%E5%82%A8%E5%99%A8.jpg)  
L1高速缓存容量达到数万字节，访问速度几乎和访问寄存器文件一样快;L2高速缓存容量为数十万到数百万字节，通过一条特殊的总线连接到处理器.二者使用了 *静态随机访问存储器* (SRAM)的硬件技术实现.  
原理 :高速缓存的局部性原理，即程序具有访问局部区域里的数据和代码的趋势.  

每个计算机系统的存储设备都被组织成了一个 *存储器层次结构*，主要思想是上一层的存储器作为第一层存储器的高速缓存.  
![1-2 一个存储器层次结构的示例](pictures/1-2%20%E4%B8%80%E4%B8%AA%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E7%9A%84%E7%A4%BA%E4%BE%8B.jpg)  

- **操作系统** :视作应用程序和软件之间插入的一层软件，两个基本功能:(1)防止硬件被失控的应用程序滥用;(2)向应用程序提供简单一致的机制来控制复杂而又通常大不相同的低级硬件设备.  
![1-3 操作系统提供的抽象表示](pictures/1-3%20%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%8F%90%E4%BE%9B%E7%9A%84%E6%8A%BD%E8%B1%A1%E8%A1%A8%E7%A4%BA.jpg)  
- **进程** :操作系统对一种正在运行的程序的一种抽象，一个系统上可以同时运行多个进程，而每个进程又好像在独占地使用硬件.而 *并发运行* 是指一个进程的指令和另一个进程的指令是交错执行的.大多数系统中，需要运行的进程数是多于可以运行它们的 CPU 个数的.并发运行是依靠处理器在进程间切换来实现的，这种机制被称为*上下文切换*.进程转换是由操作系统 *内核* (kernel) 管理的，它是系统管理全部进程所用代码与数据结构的集合.  

- **线程** :一个进程可以有多个称为线程的执行单元组成，每个线程都运行在进程的上下文中，并共享同样的代码和全局数据.

- **虚拟内存** :是每个进程看似独占使用主存.每个进程看到的内存都是一致的，称为 *虚拟地址空间*.  
下图为 Linux 进程的虚拟地址空间，图中的地址是从下往上增大的，最上面的区域是保留给操作系统中的代码和数据的，底部区域存放用户进程定义的代码和数据.
![1-4 进程的虚拟地址空间](pictures/1-4%20%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4.jpg)  
自下往上为:  
    - **程序代码和数据** :代码从一固定地址开始，但不是零地址.开始运行时大小即被指定.  
    - **堆** :堆的大小可以在运行时动态地扩展和收缩(如调用 malloc 和 free).  
    - **共享库** :存放类似于 C 标准库和数学库这样的共享库的代码和数据的区域.  
    - **栈** :位于用户虚拟地址空间顶部的是 *用户栈*，编译器用它来实现函数调用，也可以动态的扩张和收缩，调用函数时增长，返回函数时收缩.  
    - **内核虚拟内存** :地址空间顶部的区域是为内核保留的，不允许应用程序读写这个区域的内容或者直接调用内核代码定义的函数.相反，其必须调用内核来执行这些操作.  

- **文件** :字节序列.每个 I/O 设备都可以被视作文件，以一个统一的视角来处理 I/O 设备.  

从一个单独的系统来看，**网络**也可视为一个 I/O 设备.  

Amdahl 定律(Amdahl's law):设系统执行某应用程序的原时间为 $T_{old}$，假设系统某部分执行所需时间与该时间的比例为 $\alpha$，而该部分性能提升比例为 $k$. 则总的执行时间  

$$T_{new} = T_{old}((1 - \alpha) + \alpha/k )$$

计算加速比 $S = T_{old}/T_{new}$ 为  

$$S = \frac{1}{(1 - \alpha ) + \alpha /k }$$

*并发* :一个同时具有多个活动的系统.  
*并行* :用并发使一个系统运行的更快.  

*线程级并发* :依赖于 *多处理器系统*.而多处理器系统的普及依赖于 *多核处理器* 和 *超线程*(hyperthreading).  
*多核处理器* 是将多个 CPU 集成到一个集成电路芯片上.  
*超线程*，有时也称 *同时多线程*，该技术允许一个 CPU 执行多个控制流的操作.超线程的处理器可以在单个时钟周期的基础上决定要执行哪一个线程.  

*指令级并行* :现代处理器可以同时执行多条指令的属性.  
*流水线* :在流水线中，将执行一条指令所需要的活动划分为不同的步骤，将处理器的硬件组织成一系列的阶段，每个阶段执行一个步骤.  
如果处理器可以达到比一个周期一条指令更快的执行效率，就称之为 *超标量*(superscalar)处理器.

*单指令、多数据并行* :即 SIMD 并行，大多是为了提高处理影像、声音和视频数据应用的执行速度.  

*抽象* 使我们可以用简单的模型去隐藏实际实现的复杂性.